\chapter{Weitere Listings}
\label{chap:listings}

\begin{lstlisting}[style=lolc,caption={Bit Manipulation Engine: \texttt{XOR}},label=lst:bme-xor]
/* ueblicher C-Code */

GPIOA_PDOR ^= 0x02; 
// 0000005E 0x.... LDR R0,??DataTable6_5 ;; 0x400ff000 
// 00000060 0x6800 LDR R0,[R0, #+0] 
// 00000062 0x2102 MOVS R1,#+2 
// 00000064 0x4041 EORS R1,R1,R0 
// 00000066 0x.... LDR R0,??DataTable6_5 ;; 0x400ff000 
// 00000068 0x6001 STR R1,[R0, #+0] 

/* Verwendung der BME */
#define BME_XOR_ADDR(ADDR) (*(volatile uint32_t *)(((uint32_t)ADDR) | (3<<26))) 

BME_XOR_ADDR(&GPIOA_PDOR) = 0x02; 
// 00000014 0x.... LDR R0,??DataTable6_6 ;; 0x4c0ff000 
// 00000016 0x2102 MOVS R1,#+2 
// 00000018 0x6001 STR R1,[R0, #+0] 
\end{lstlisting}

\begin{lstlisting}[style=lolmatlab,caption={Ellipsoid-Fitting in MATLAB},label=lst:matlab-ellipsoid]
function [ center, radii, evecs, v ] = ellipsoid_fit( X )
% 3D ellipsoid fitting (c) 2009 Yury Petrov.

  % fit ellipsoid in the form Ax^2 + By^2 + Cz^2 + 2Dxy + 2Exz + 2Fyz + 2Gx + 2Hy + 2Iz = 1
  D = [ x .* x, ...
        y .* y, ...
        z .* z, ...
    2 * x .* y, ...
    2 * x .* z, ...
    2 * y .* z, ...
    2 * x, ...
    2 * y, ... 
    2 * z ];  % ndatapoints x 9 ellipsoid parameters

  % solve the normal system of equations
  v = ( D' * D ) \ ( D' * ones( size( x, 1 ), 1 ) );

  % find the ellipsoid parameters

  % form the algebraic form of the ellipsoid
  A = [ v(1) v(4) v(5) v(7); ...
        v(4) v(2) v(6) v(8); ...
        v(5) v(6) v(3) v(9); ...
        v(7) v(8) v(9) -1 ];
  % find the center of the ellipsoid
  center = -A( 1:3, 1:3 ) \ [ v(7); v(8); v(9) ];

  % form the corresponding translation matrix
  T = eye( 4 );
  T( 4, 1:3 ) = center';
  
  % translate to the center
  R = T * A * T';
  
  % solve the eigenproblem
  [ evecs evals ] = eig( R( 1:3, 1:3 ) / -R( 4, 4 ) );
  radii = sqrt( 1 ./ diag( evals ) );

end
\end{lstlisting}

\begin{lstlisting}[style=lolmatlab,caption={Setup des \gls{p2pp}-Decoders in MATLAB},label=lst:matlab-p2ppdecoder-setup]
function prepareProtocolDecode
        
    % Definitions
    global SOH EOT ESC ESC_XOR DA TA
    SOH     = uint8(1);
    EOT     = uint8(4);
    ESC     = uint8(27);
    ESC_XOR = uint8(66);
    DA      = uint8(218);
    TA      = uint8(122);

    global state
    state = 0;
    
    % Decoding variables
    global dataLength data dataBytesRead escapeDetected dataReady lastByte
    lastByte = NaN;
    dataLength = 0;
    data = [];
    dataBytesRead = 0;
    escapeDetected = false;
    dataReady = false;
    
    % Data counters
    global sensorDataCount RPY
    RPY = 1;
    sensorDataCount = zeros(3,1);
end
\end{lstlisting}

\begin{lstlisting}[style=lolmatlab,caption={\gls{p2pp}-Decoder in MATLAB},label=lst:matlab-p2ppdecoder]
function [availableData] = protocolDecode(byte)
    global SOH EOT ESC ESC_XOR DA TA
    global state
    global dataLength data dataReady dataBytesRead escapeDetected lastByte

    availableData = 0;
    
    % Switch states
    switch state
        % Await preamble
        case 0
            if byte == DA
                % ignored
            elseif (byte == TA) && (lastByte == DA)
                state = 1; % preamble detected
            else
                % error state
            end

            lastByte = byte;

        % Await SOH
        case 1
            if byte == SOH
                state = 2;
            else
                % error state
            end

        % Read length
        case 2
            dataLength = byte;
            dataBytesRead = 0;
            data = zeros(dataLength, 1, 'uint8');
            state = 3;

        % Read data bytes
        case 3
            if byte == ESC
                escapeDetected = true;
            else
                if escapeDetected
                    byte = bitxor(byte, ESC_XOR);
                    escapeDetected = false;
                end

                dataBytesRead = dataBytesRead + 1;
                data(dataBytesRead) = byte;

                if dataBytesRead == dataLength
                    state = 4;
                end
            end

        % Await EOT
        case 4
            if byte == EOT
                state = 0;
                dataReady = true;
                availableData = dataBytesRead;
            else
                % error state
            end
    end
end
\end{lstlisting}

\begin{lstlisting}[style=lolcsharp,caption={\gls{p2pp}-Decoder in C\#},label=lst:csharp-p2ppdecoder]
class ProtocolDecoder
{
	private const int SOH = 1;
	private const int EOT = 4;
	private const int ESC = 27;
	private const int ESC_XOR = 66;
	private const int DA = 218;
	private const int TA = 122;
	
	private int dataLength = 0;
	private int dataBytesRead = 0;
	private byte[] data;

	private int lastdatum = 0;
	private bool escapeDetected = false;
	private int state = 0;

	public event EventHandler<DataEvent> DataReady;

	/// <summary>
	/// Decodes the specified data btye.
	/// </summary>
	/// <param name="datum">The data byte.</param>
	public void Decode(int datum)
	{
		switch (state)
		{
			case 0: // Await preamble
			{
				if (datum == DA) { /* ignored */ }
				else if ((datum == TA) && (lastdatum == DA))
				{
					// preamble detected
					state = 1;
					break;
				}
				else { /* error case */ }

				// Remember datum for protocol decoding
				lastdatum = datum;
				break;
			}

			case 1: // Await SOH
			{
				if (datum == SOH)
				{
					state = 2; break;
				}
				
				state = 0; // error case
				break;
			}

			case 2: // Read length
			{
				dataLength = datum;
				dataBytesRead = 0;
				data = new byte[dataLength];
				state = 3;
				break;
			}

			case 3: // Read datum
			{
				if (datum == ESC)
				{
					escapeDetected = true;
				}
				else
				{
					// decode escaped byte
					if (escapeDetected)
					{
						datum = datum ^ ESC_XOR;
						escapeDetected = false;
					}

					// store data byte and increment counter
					data[dataBytesRead++] = (byte)datum;

					// if all bytes are read, wait for EOT
					if (dataBytesRead == dataLength)
					{
						state = 4;
					}
				}
				break;
			}
			case 4: // await EOT
			{
				if (datum == EOT)
				{
					state = 0;

					// raise event
					var handler = DataReady;
					if (handler != null)
					{
						handler(this, new DataEvent(data));
					}
					
					break;
				}
				
				state = 0; // error case
				break;
			}
		}
	}
}
\end{lstlisting}

\begin{lstlisting}[style=lolmatlab,caption={Plot eines virtuellen Horizontes in MATLAB},label=lst:matlab-virthorz]
function virtualHorizonPlot(rp) % rp = roll and pitch

	% get factors
	rpfactors = rp * 4 / pi;
	intercept = -rpfactors(2);
	
	% get affine transformation matrix
	roll = rp(1);
	R = [cos(roll), -sin(roll), 0;
	     sin(roll), cos(roll), 0;
	     0, 0, 1];
	T = [1, 0, 0;
	     0, 1, intercept;
	     0, 0, 1];
	 A =T*R;

	% rotated corner vertices
	size = 4;
	topLeft     = A*[-size;  size; 1];
	topRight    = A*[ size;  size; 1];
	bottomLeft  = A*[-size; -size; 1];a
	bottomRight = A*[ size; -size; 1];
	middleLeft  = 0.5*(topLeft+bottomLeft);
	middleRight  = 0.5*(topRight+bottomRight);
			
	% plot horizon
	hold off;
	
	% ground plot
	fill(...
	    [middleLeft(1) middleRight(1) bottomRight(1) bottomLeft(1)], ...
	    [middleLeft(2) middleRight(2) bottomRight(2) bottomLeft(2)], ...
	    [0.41176 0.27059 0.17647] ...
	    );
	hold on;
	
	% sky plot
	fill( ...
	    [middleLeft(1) topLeft(1) topRight(1) middleRight(1)], ...
	    [middleLeft(2) topLeft(2) topRight(2) middleRight(2)], ...
	    [0.094118 0.48627 0.68235] ...
	    );

	% Correct axes
	set(gca, ...
	   'Visible', 'off' ...
	    );

	axis square;
	xlim([-1 1]);
	ylim([-1 1]);
end
\end{lstlisting}

\begin{lstlisting}[style=lolmatlab,caption={Umwandlung des Accelerometer-Vektors in Roll- und Pitch-Winkel in MATLAB},label=lst:matlab-rollpitch]
function [rp] = rollpitch(acc)
	% ROLLPITCH Calculates roll and pitch angles from measured acceleration
	%
	%   Parameters
	%   acc = 3D vector of component accelerations [x; y; z]
	%         where z is interpreted as up vector, that is, if the
	%         accelerometer measures 1g downwards, then z is positive.
	%         
	%
	%   Return values
	%   vector [roll; pitch] in radians

	% Get normalized component vectors
	invn = 1/norm(acc);
	x =  [1; 0; 0] * acc(1) * invn;
	y =  [0; 1; 0] * acc(2) * invn;

	% Reference vector
	zref = [0; 0; 1];

	% Prepare result
	rp = [NaN; NaN];
	
	% Get y-z component angle (roll)
	zy_cross = cross(zref, y);
	yangle   = zy_cross(1);
	rp(1)    = asin(yangle);
	if acc(3) > 0
		 rp(1) = pi - rp(1);
	end
	
	% Get x-z component angle (pitch)
	xz_cross = cross(x, zref);
	xangle   = xz_cross(2);
	rp(2)     = asin(xangle);
	if acc(3) > 0
		rp(2) = -rp(2);
	end
end
\end{lstlisting}

\begin{lstlisting}[style=lolc,caption={Gravitations-Beispiel mittels kalman-clib},label=lst:kalman-clib]
/*!
* The formulas used are:
* s = s + v*T + g*0.5*T^2
* v = v + g*T
* g = g
*
* The time constant is set to T = 1s.
* The initial estimation of the gravity constant is set to 6 m/s^2.
*/

#include <assert.h>
#include "kalman_example_gravity.h"

// create the filter structure
#define KALMAN_NAME gravity
#define KALMAN_NUM_STATES 3
#define KALMAN_NUM_INPUTS 0
#include "kalman_factory_filter.h"

// create the measurement structure
#define KALMAN_MEASUREMENT_NAME position
#define KALMAN_NUM_MEASUREMENTS 1
#include "kalman_factory_measurement.h"

// clean up
#include "kalman_factory_cleanup.h"

/*!
* \brief Initializes the gravity Kalman filter
*/
static void kalman_gravity_init()
{
    /* initialize the filter structures */
    kalman_t *kf = kalman_filter_gravity_init();
    kalman_measurement_t *kfm = kalman_filter_gravity_measurement_position_init();

    /* set initial state */
    matrix_t *x = kalman_get_state_vector(kf);
    x->data[0] = 0; // s_i
    x->data[1] = 0; // v_i
    x->data[2] = 6; // g_i

    /* set state transition */
    matrix_t *A = kalman_get_state_transition(kf);
    
    /* set time constant */
    const matrix_data_t T = 1;

    /* transition of x to s */
    matrix_set(A, 0, 0, 1);   // 1
    matrix_set(A, 0, 1, T);   // T
    matrix_set(A, 0, 2, (matrix_data_t)0.5*T*T); // 0.5 * T^2
    
    /* transition of x to v */
    matrix_set(A, 1, 0, 0);   // 0
    matrix_set(A, 1, 1, 1);   // 1
    matrix_set(A, 1, 2, T);   // T

    /* transition of x to g */
    matrix_set(A, 2, 0, 0);   // 0
    matrix_set(A, 2, 1, 0);   // 0
    matrix_set(A, 2, 2, 1);   // 1

    /* set covariance */
    matrix_t *P = kalman_get_system_covariance(kf);

    matrix_set_symmetric(P, 0, 0, (matrix_data_t)0.1);   // var(s)
    matrix_set_symmetric(P, 0, 1, 0);   // cov(s,v)
    matrix_set_symmetric(P, 0, 2, 0);   // cov(s,g)

    matrix_set_symmetric(P, 1, 1, 1);   // var(v)
    matrix_set_symmetric(P, 1, 2, 0);   // cov(v,g)

    matrix_set_symmetric(P, 2, 2, 1);   // var(g)

    /* set measurement transformation */
    matrix_t *H = kalman_get_measurement_transformation(kfm);

    matrix_set(H, 0, 0, 1);     // z = 1*s 
    matrix_set(H, 0, 1, 0);     //   + 0*v
    matrix_set(H, 0, 2, 0);     //   + 0*g

    /* set process noise */
    matrix_t *R = kalman_get_process_noise(kfm);

    matrix_set(R, 0, 0, (matrix_data_t)0.5);     // var(s)
}

// define measurements.
//
// MATLAB source
// -------------
// s = s + v*T + g*0.5*T^2; 
// v = v + g*T;
#define MEAS_COUNT (15)
static matrix_data_t real_distance[MEAS_COUNT] = {
    (matrix_data_t)0,
    (matrix_data_t)4.905,
    /* ... snip ... */
    (matrix_data_t)828.94,
    (matrix_data_t)961.38 };

// define measurement noise with variance 0.5
//
// MATLAB source
// -------------
// noise = 0.5^2*randn(15,1);
static matrix_data_t measurement_error[MEAS_COUNT] = {
    (matrix_data_t)0.13442,
    /* ... snip ... */
    (matrix_data_t)-0.015764,
    (matrix_data_t)0.17869 };

/*!
* \brief Runs the gravity Kalman filter.
*/
void kalman_gravity_demo()
{
    // initialize the filter
    kalman_gravity_init();

    // fetch structures
    kalman_t *kf = &kalman_filter_gravity;
    kalman_measurement_t *kfm = &kalman_filter_gravity_measurement_position;

    matrix_t *x = kalman_get_state_vector(kf);
    matrix_t *z = kalman_get_measurement_vector(kfm);
    
    // filter!
    for (int i = 0; i < MEAS_COUNT; ++i)
    {
        // prediction.
        kalman_predict(kf);

        // measure ...
        matrix_data_t measurement = real_distance[i] + measurement_error[i];
        matrix_set(z, 0, 0, measurement);

        // update
        kalman_correct(kf, kfm);
    }

    // fetch estimated g
    matrix_data_t g_estimated = x->data[2];
    assert(g_estimated > 9 && g_estimated < 10);
}
\end{lstlisting}

\begin{lstlisting}[style=lolc,caption={Gravitations-Beispiel mittels libfixkalman},label=lst:libfixkalman]
/*!
* The formulas used are:
* s = s + v*T + g*0.5*T^2
* v = v + g*T
* g = g
*
* The time constant is set to T = 1s.
* The initial estimation of the gravity constant is set to 6 m/s^2.
*/

// no control inputs given, so _uc type used
kalman16_uc_t kf;

kalman16_observation_t kfm;

#define matrix_set(matrix, row, column, value) \
    matrix->data[row][column] = value

#define matrix_set_symmetric(matrix, row, column, value) \
    matrix->data[row][column] = value; \
    matrix->data[column][row] = value

/*!
* \brief Initializes the gravity Kalman filter
*/
static void kalman_gravity_init()
{
    /* initialize the filter structures */
    kalman_filter_initialize_uc(&kf, KALMAN_NUM_STATES);
    kalman_observation_initialize(&kfm, KALMAN_NUM_STATES, KALMAN_NUM_MEASUREMENTS);

    /* set initial state */
    mf16 *x = kalman_get_state_vector_uc(&kf);
    x->data[0][0] = 0; // s_i
    x->data[1][0] = 0; // v_i
    x->data[2][0] = fix16_from_float(6); // g_i

    /* set state transition */
    mf16 *A = kalman_get_state_transition_uc(&kf);
    
    /* set time constant */
    const fix16_t T = fix16_one;
    const fix16_t Tsquare = fix16_sq(T);

    /* helper */
    const fix16_t fix16_half = fix16_from_float(0.5);

    /* transition of x to s */
    matrix_set(A, 0, 0, fix16_one);   // 1
    matrix_set(A, 0, 1, T);   // T
    matrix_set(A, 0, 2, fix16_mul(fix16_half, Tsquare)); // 0.5 * T^2
    
    /* transition of x to v */
    matrix_set(A, 1, 0, 0);   // 0
    matrix_set(A, 1, 1, fix16_one);   // 1
    matrix_set(A, 1, 2, T);   // T

    /* transition of x to g */
    matrix_set(A, 2, 0, 0);   // 0
    matrix_set(A, 2, 1, 0);   // 0
    matrix_set(A, 2, 2, fix16_one);   // 1

    /* set covariance */
    mf16 *P = kalman_get_system_covariance_uc(&kf);

    matrix_set_symmetric(P, 0, 0, fix16_half);   // var(s)
    matrix_set_symmetric(P, 0, 1, 0);   // cov(s,v)
    matrix_set_symmetric(P, 0, 2, 0);   // cov(s,g)

    matrix_set_symmetric(P, 1, 1, fix16_one);   // var(v)
    matrix_set_symmetric(P, 1, 2, 0);   // cov(v,g)

    matrix_set_symmetric(P, 2, 2, fix16_one);   // var(g)

    /* set system process noise */
    mf16 *Q = kalman_get_system_process_noise_uc(&kf);
    mf16_fill(Q, F16(0.0001));

    /* set measurement transformation */
    mf16 *H = kalman_get_observation_transformation(&kfm);

    matrix_set(H, 0, 0, fix16_one);     // z = 1*s 
    matrix_set(H, 0, 1, 0);     //   + 0*v
    matrix_set(H, 0, 2, 0);     //   + 0*g

    /* set process noise */
    mf16 *R = kalman_get_observation_process_noise(&kfm);

    matrix_set(R, 0, 0, fix16_half);     // var(s)
}

// define measurements.
//
// MATLAB source
// -------------
// s = s + v*T + g*0.5*T^2; 
// v = v + g*T;
#define MEAS_COUNT (15)
static fix16_t real_distance[MEAS_COUNT] = {
    F16(4.905),
    /* ... snip ... */
    F16(961.38),
    F16(1103.6) };

// define measurement noise with variance 0.5
//
// MATLAB source
// -------------
// noise = 0.5^2*randn(15,1);
static fix16_t measurement_error[MEAS_COUNT] = {
    F16(0.13442),
    /* ... snip ... */
    F16(-0.015764),
    F16(0.17869) };

/*!
* \brief Runs the gravity Kalman filter.
*/
void kalman_gravity_demo()
{
    // initialize the filter
    kalman_gravity_init();

    mf16 *x = kalman_get_state_vector_uc(&kf);
    mf16 *z = kalman_get_observation_vector(&kfm);
    
    // filter!
    uint_fast16_t i;
    for (i = 0; i < MEAS_COUNT; ++i)
    {
        // prediction.
        kalman_predict_uc(&kf);

        // measure ...
        fix16_t measurement = fix16_add(real_distance[i], measurement_error[i]);
        matrix_set(z, 0, 0, measurement);

        // update
        kalman_correct_uc(&kf, &kfm);
    }

    // fetch estimated g
    const fix16_t g_estimated = x->data[2][0];
    const float value = fix16_to_float(g_estimated);
    assert(value > 9.7 && value < 10);
}
\end{lstlisting}

\begin{lstlisting}[style=lolc,caption={Fusion: \textsc{Euler}'sche Winkel aus \gls{dcm}},label=lst:libfixmath_dcm_euler]
void sensor_dcm2rpy(
	const mf16 *RESTRICT const dcm, 
	fix16_t *RESTRICT const roll, 
	fix16_t *RESTRICT const pitch, 
	fix16_t *RESTRICT const yaw)
{
    *pitch = -fix16_asin(dcm->data[0][2]);
    *roll  = fix16_atan2(dcm->data[1][2], dcm->data[2][2]);
    *yaw   = fix16_atan2(dcm->data[0][1], dcm->data[0][0]);
}
\end{lstlisting}

\begin{lstlisting}[style=lolc,caption={Fusion: Ermittlung des Quaternions aus den fusionierten Datem},label=lst:quaternion_from_kalman]
HOT NONNULL LEAF
static void fetch_quaternion_opt2(register qf16 *RESTRICT const quat)
{
	const register mf16 *const x2 = kalman_get_state_vector_uc(&kf_orientation);
	const register mf16 *const x3 = kalman_get_state_vector_uc(&kf_attitude);

	// m00 = R(1, 1);    m01 = R(1, 2);    m02 = R(1, 3);
	// m10 = R(2, 1);    m11 = R(2, 2);    m12 = R(2, 3);
	// m20 = R(3, 1);    m21 = R(3, 2);    m22 = R(3, 3);

	const fix16_t m10 = x2->data[0][0];
	const fix16_t m11 = x2->data[1][0];
	const fix16_t m12 = x2->data[2][0];

	const fix16_t m20 = -x3->data[0][0];
	const fix16_t m21 = -x3->data[1][0];
	const fix16_t m22 = -x3->data[2][0];

	// calculate cross product for C1
	// m0 = cross([m10 m11 m12], [m20 m21 m22])
	// -->
	//      m00 = m11*m22 - m12*m21
	//      m01 = m12*m20 - m10*m22
	//      m02 = m10*m21 - m11*m20
	fix16_t m00 = fix16_sub(fix16_mul(m11, m22), fix16_mul(m12, m21));
	fix16_t m01 = fix16_sub(fix16_mul(m12, m20), fix16_mul(m10, m22));
	fix16_t m02 = fix16_sub(fix16_mul(m10, m21), fix16_mul(m11, m20));

	// normalize C1 
	const register fix16_t norm = norm3(m00, m01, m02);
	m00 = fix16_div(m00, norm);
	m01 = fix16_div(m01, norm);
	m02 = fix16_div(m02, norm);

	// "Angel" code
	// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/

	fix16_t qw, qx, qy, qz;

	// check the matrice's trace
	const register fix16_t trace = fix16_add(m00, fix16_add(m11, m22));
	if (trace > 0)
	{
		/*
		s = 0.5 / sqrt(trace + 1.0);
		qw = 0.25 / s;
		qx = ( R(3,2) - R(2,3) ) * s;
		qy = ( R(1,3) - R(3,1) ) * s;
		qz = ( R(2,1) - R(1,2) ) * s;
		*/

		const fix16_t s = fix16_div(F16(0.5), fix16_sqrt(fix16_add(F16(1.0), trace)));

		qw = fix16_div(F16(0.25), s);
		qx = fix16_mul(fix16_sub(m21, m12), s);
		qy = fix16_mul(fix16_sub(m02, m20), s);
		qz = fix16_mul(fix16_sub(m10, m01), s);
	}
	else
	{
		if (m00 > m11 && m00 > m22)
		{
			/*
			s = 2.0 * sqrt( 1.0 + R(1,1) - R(2,2) - R(3,3));
			qw = (R(3,2) - R(2,3) ) / s;
			qx = 0.25 * s;
			qy = (R(1,2) + R(2,1) ) / s;
			qz = (R(1,3) + R(3,1) ) / s;
			*/
			const fix16_t s = fix16_mul(F16(2), fix16_sqrt(fix16_add(F16(1), fix16_sub(m00, fix16_add(m11, m22)))));

			qw = fix16_div(fix16_sub(m21, m12), s);
			qx = fix16_mul(F16(0.25), s);
			qy = fix16_div(fix16_add(m01, m10), s);
			qz = fix16_div(fix16_add(m02, m20), s);
		}
		else if (m11 > m22)
		{
			/*
			s = 2.0 * sqrt( 1.0 + R(2,2) - R(1,1) - R(3,3));
			qw = (R(1,3) - R(3,1) ) / s;
			qx = (R(1,2) + R(2,1) ) / s;
			qy = 0.25 * s;
			qz = (R(2,3) + R(3,2) ) / s;
			*/
			const fix16_t s = fix16_mul(F16(2), fix16_sqrt(fix16_add(F16(1), fix16_sub(m11, fix16_add(m00, m22)))));

			qw = fix16_div(fix16_sub(m02, m20), s);
			qx = fix16_div(fix16_add(m01, m10), s);
			qy = fix16_mul(F16(0.25), s);
			qz = fix16_div(fix16_add(m12, m21), s);
		}
		else
		{
			/*
			s = 2.0 * sqrt( 1.0 + R(3,3) - R(1,1) - R(2,2) );
			qw = (R(2,1) - R(1,2) ) / s;
			qx = (R(1,3) + R(3,1) ) / s;
			qy = (R(2,3) + R(3,2) ) / s;
			qz = 0.25 * s;
			*/
			const fix16_t s = fix16_mul(F16(2), fix16_sqrt(fix16_add(F16(1), fix16_sub(m22, fix16_add(m00, m11)))));

			qw = fix16_div(fix16_sub(m10, m01), s);
			qx = fix16_div(fix16_add(m02, m20), s);
			qy = fix16_div(fix16_add(m12, m21), s);
			qz = fix16_mul(F16(0.25), s);
		}
	}

	// compose quaternion
	quat->a = qw;
	quat->b = qx;
	quat->c = qy;
	quat->d = qz;

	// normalizify
	qf16_normalize(quat, quat);
}
\end{lstlisting}

\begin{lstlisting}[style=lolc,caption={Fusion: Berechnung des VorwÃ¤rtsvektors aus Magnetometer und Accelerometer},label=lst:magnetometer_project]
HOT LEAF NONNULL
STATIC_INLINE void magnetometer_project(
	fix16_t *RESTRICT const mx, 
	fix16_t *RESTRICT const my, 
	fix16_t *RESTRICT const mz)
{
	const mf16 *const x = kalman_get_state_vector_uc(&kf_attitude);

	register const fix16_t acc_x = x->data[0][0];
	register const fix16_t acc_y = x->data[1][0];
	register const fix16_t acc_z = x->data[2][0];

	/************************************************************************/
	/* Instead of tilt corrected magnetometer, use TRIAD algorithm          */
	/************************************************************************/

	// calculate cross product for C1
	// m = cross([m_magnetometer.x m_magnetometer.y m_magnetometer.z], [m_accelerometer.x m_accelerometer.y m_accelerometer.z])
	// -->
	//      mx = m_magnetometer.y*m_accelerometer.z - m_magnetometer.z*m_accelerometer.y
	//      my = m_magnetometer.z*m_accelerometer.x - m_magnetometer.x*m_accelerometer.z
	//      mz = m_magnetometer.x*m_accelerometer.y - m_magnetometer.y*m_accelerometer.x
	*mx = fix16_sub(fix16_mul(m_magnetometer.y, acc_z), fix16_mul(m_magnetometer.z, acc_y));
	*my = fix16_sub(fix16_mul(m_magnetometer.z, acc_x), fix16_mul(m_magnetometer.x, acc_z));
	*mz = fix16_sub(fix16_mul(m_magnetometer.x, acc_y), fix16_mul(m_magnetometer.y, acc_x));

	// normalize C1 
	const register fix16_t norm = norm3(*mx, *my, *mz);
	*mx = fix16_div(*mx, norm);
	*my = fix16_div(*my, norm);
	*mz = fix16_div(*mz, norm);
}
\end{lstlisting}

\begin{lstlisting}[style=lolc,caption={Fusion: Korrektur des \emph{orientation}-Filters mittels Magnetometer},label=lst:magnetometer_correct]
HOT
static void fusion_update_orientation(register const fix16_t deltaT)
{
	/************************************************************************/
	/* Calculate metrics required for update                                */
	/************************************************************************/
	fix16_t mx, my, mz;
	magnetometer_project(&mx, &my, &mz);
	
	/************************************************************************/
	/* Prepare noise                                                        */
	/************************************************************************/

	tune_measurement_noise(&kfm_magneto);
	{
		mf16 *const R = &kfm_magneto.R;

		// anyway, overwrite covariance of projection
		matrix_set(R, 0, 0, fix16_mul(initial_r_projection, alpha1));
		matrix_set(R, 1, 1, fix16_mul(initial_r_projection, alpha1));
		matrix_set(R, 2, 2, fix16_mul(initial_r_projection, alpha1));
	}

	/************************************************************************/
	/* Prepare measurement                                                  */
	/************************************************************************/
	{
		mf16 *const z = &kfm_magneto.z;

		matrix_set(z, 0, 0, mx);
		matrix_set(z, 1, 0, my);
		matrix_set(z, 2, 0, mz);

		matrix_set(z, 3, 0, kf_attitude.x.data[3][0]);
		matrix_set(z, 4, 0, kf_attitude.x.data[4][0]);
		matrix_set(z, 5, 0, kf_attitude.x.data[5][0]);
	}

	/************************************************************************/
	/* Perform Kalman update                                                */
	/************************************************************************/

	kalman_correct_uc(&kf_orientation, &kfm_magneto);

	/************************************************************************/
	/* Re-orthogonalize and update state matrix                             */
	/************************************************************************/

	fusion_sanitize_state(&kf_orientation);
}
\end{lstlisting}

\begin{lstlisting}[style=lolc,caption={KL25Z: Aktivierung des 48MHz-\gls{pll}-Modus des \gls{mcg}},label=lst:kl25z-pll-init]
int pll_init(int crystal_val, unsigned char hgo_val, unsigned char erefs_val, signed char prdiv_val, signed char vdiv_val, unsigned char mcgout_select)
{
  unsigned char frdiv_val;
  unsigned char temp_reg;
  unsigned char prdiv, vdiv;
  short i;
  int ref_freq;
  int pll_freq;

  // check if in FEI mode
  if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selected FLL output
      (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
      (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
  {
    return 0x1;                                                     // return error code
  }

  // check external frequency is less than the maximum frequency
  if  (crystal_val > 50000000) {return 0x21;}

  // check crystal frequency is within spec. if crystal osc is being used as PLL ref
  if (erefs_val)
  {
    if ((crystal_val < 3000000) || (crystal_val > 32000000)) {return 0x22;} // return 1 if one of the available crystal options is not available
  }

  // make sure HGO will never be greater than 1. Could return an error instead if desired.
  if (hgo_val > 0)
  {
    hgo_val = 1; // force hgo_val to 1 if > 0
  }

  // Check PLL divider settings are within spec.
  if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
  if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}

  // Check PLL reference clock frequency is within spec.
  ref_freq = crystal_val / prdiv_val;
  if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}

  // Check PLL output frequency is within spec.
  pll_freq = (crystal_val / prdiv_val) * vdiv_val;
  if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}

  // configure the MCG_C2 register
  // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
  // it still needs to be set correctly even if the oscillator is not being used
      
  temp_reg = MCG_C2;
  temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
    
  if (crystal_val <= 8000000)
  {
    temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
  }
  else
  {
    temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
  }
  MCG_C2 = temp_reg;
  
  // determine FRDIV based on reference clock frequency
  // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
  if (crystal_val <= 1250000) {frdiv_val = 0;}
  else if (crystal_val <= 2500000) {frdiv_val = 1;}
  else if (crystal_val <= 5000000) {frdiv_val = 2;}
  else if (crystal_val <= 10000000) {frdiv_val = 3;}
  else if (crystal_val <= 20000000) {frdiv_val = 4;}
  else {frdiv_val = 5;}

  // Select external oscillator and Reference Divider and clear IREFS to start ext osc
  // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
  // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
  temp_reg = MCG_C1;
  temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these fields
  temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
  MCG_C1 = temp_reg;

  // if the external oscillator is used need to wait for OSCINIT to set
  if (erefs_val)
  {
    for (i = 0 ; i < 20000 ; i++)
    {
      if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
    }
  if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
  }

  // wait for Reference clock Status bit to clear
  for (i = 0 ; i < 2000 ; i++)
  {
    if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
  }
  if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set

  // Wait for clock status bits to show clock source is ext ref clk
  for (i = 0 ; i < 2000 ; i++)
  {
    if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
  }
  if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not

  // Now in FBE
  // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
  // It is enabled here but can be removed if this is not required.
  MCG_C6 |= MCG_C6_CME0_MASK;
  
  // Configure PLL
  // Configure MCG_C5
  // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user code.
  temp_reg = MCG_C5;
  temp_reg &= ~MCG_C5_PRDIV0_MASK;
  temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
  MCG_C5 = temp_reg;

  // Configure MCG_C6
  // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
  // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
  temp_reg = MCG_C6; // store present C6 value
  temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
  temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
  MCG_C6 = temp_reg; // update MCG_C6

  // wait for PLLST status bit to set
  for (i = 0 ; i < 2000 ; i++)
  {
    if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
  }
  if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if not set

  // Wait for LOCK bit to set
  for (i = 0 ; i < 4000 ; i++)
  {
    if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
  }
  if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if not set

  // Use actual PLL settings to calculate PLL frequency
  prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
  vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);

  // now in PBE

  MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT

  // Wait for clock status bits to update
  for (i = 0 ; i < 2000 ; i++)
  {
    if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST = 3 before loop finishes
  }
  if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set correctly and return with error if not

  // Now in PEE
  
  return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
} // pll_init
\end{lstlisting}