\chapter{Weitere Listings}
\label{chap:listings}

\begin{lstlisting}[style=lolc,caption={Bit Manipulation Engine: \texttt{XOR}},label=lst:bme-xor]
/* ueblicher C-Code */

GPIOA_PDOR ^= 0x02; 
// 0000005E 0x.... LDR R0,??DataTable6_5 ;; 0x400ff000 
// 00000060 0x6800 LDR R0,[R0, #+0] 
// 00000062 0x2102 MOVS R1,#+2 
// 00000064 0x4041 EORS R1,R1,R0 
// 00000066 0x.... LDR R0,??DataTable6_5 ;; 0x400ff000 
// 00000068 0x6001 STR R1,[R0, #+0] 

/* Verwendung der BME */
#define BME_XOR_ADDR(ADDR) (*(volatile uint32_t *)(((uint32_t)ADDR) | (3<<26))) 

BME_XOR_ADDR(&GPIOA_PDOR) = 0x02; 
// 00000014 0x.... LDR R0,??DataTable6_6 ;; 0x4c0ff000 
// 00000016 0x2102 MOVS R1,#+2 
// 00000018 0x6001 STR R1,[R0, #+0] 
\end{lstlisting}

\begin{lstlisting}[style=lolmatlab,caption={Setup des \gls{p2pp}-Decoders in MATLAB},label=lst:matlab-p2ppdecoder-setup]
function prepareProtocolDecode
        
    % Definitions
    global SOH EOT ESC ESC_XOR DA TA
    SOH     = uint8(1);
    EOT     = uint8(4);
    ESC     = uint8(27);
    ESC_XOR = uint8(66);
    DA      = uint8(218);
    TA      = uint8(122);

    global state
    state = 0;
    
    % Decoding variables
    global dataLength data dataBytesRead escapeDetected dataReady lastByte
    lastByte = NaN;
    dataLength = 0;
    data = [];
    dataBytesRead = 0;
    escapeDetected = false;
    dataReady = false;
    
    % Data counters
    global sensorDataCount RPY
    RPY = 1;
    sensorDataCount = zeros(3,1);
end
\end{lstlisting}

\begin{lstlisting}[style=lolmatlab,caption={\gls{p2pp}-Decoder in MATLAB},label=lst:matlab-p2ppdecoder]
function [availableData] = protocolDecode(byte)
    global SOH EOT ESC ESC_XOR DA TA
    global state
    global dataLength data dataReady dataBytesRead escapeDetected lastByte

    availableData = 0;
    
    % Switch states
    switch state
        % Await preamble
        case 0
            if byte == DA
                % ignored
            elseif (byte == TA) && (lastByte == DA)
                state = 1; % preamble detected
            else
                % error state
            end

            lastByte = byte;

        % Await SOH
        case 1
            if byte == SOH
                state = 2;
            else
                % error state
            end

        % Read length
        case 2
            dataLength = byte;
            dataBytesRead = 0;
            data = zeros(dataLength, 1, 'uint8');
            state = 3;

        % Read data bytes
        case 3
            if byte == ESC
                escapeDetected = true;
            else
                if escapeDetected
                    byte = bitxor(byte, ESC_XOR);
                    escapeDetected = false;
                end

                dataBytesRead = dataBytesRead + 1;
                data(dataBytesRead) = byte;

                if dataBytesRead == dataLength
                    state = 4;
                end
            end

        % Await EOT
        case 4
            if byte == EOT
                state = 0;
                dataReady = true;
                availableData = dataBytesRead;
            else
                % error state
            end
    end
end
\end{lstlisting}

\begin{lstlisting}[style=lolcsharp,caption={\gls{p2pp}-Decoder in C\#},label=lst:csharp-p2ppdecoder]
class ProtocolDecoder
{
	private const int SOH = 1;
	private const int EOT = 4;
	private const int ESC = 27;
	private const int ESC_XOR = 66;
	private const int DA = 218;
	private const int TA = 122;
	
	private int dataLength = 0;
	private int dataBytesRead = 0;
	private byte[] data;

	private int lastdatum = 0;
	private bool escapeDetected = false;
	private int state = 0;

	public event EventHandler<DataEvent> DataReady;

	/// <summary>
	/// Decodes the specified data btye.
	/// </summary>
	/// <param name="datum">The data byte.</param>
	public void Decode(int datum)
	{
		switch (state)
		{
			case 0: // Await preamble
			{
				if (datum == DA) { /* ignored */ }
				else if ((datum == TA) && (lastdatum == DA))
				{
					// preamble detected
					state = 1;
					break;
				}
				else { /* error case */ }

				// Remember datum for protocol decoding
				lastdatum = datum;
				break;
			}

			case 1: // Await SOH
			{
				if (datum == SOH)
				{
					state = 2; break;
				}
				
				state = 0; // error case
				break;
			}

			case 2: // Read length
			{
				dataLength = datum;
				dataBytesRead = 0;
				data = new byte[dataLength];
				state = 3;
				break;
			}

			case 3: // Read datum
			{
				if (datum == ESC)
				{
					escapeDetected = true;
				}
				else
				{
					// decode escaped byte
					if (escapeDetected)
					{
						datum = datum ^ ESC_XOR;
						escapeDetected = false;
					}

					// store data byte and increment counter
					data[dataBytesRead++] = (byte)datum;

					// if all bytes are read, wait for EOT
					if (dataBytesRead == dataLength)
					{
						state = 4;
					}
				}
				break;
			}
			case 4: // await EOT
			{
				if (datum == EOT)
				{
					state = 0;

					// raise event
					var handler = DataReady;
					if (handler != null)
					{
						handler(this, new DataEvent(data));
					}
					
					break;
				}
				
				state = 0; // error case
				break;
			}
		}
	}
}
\end{lstlisting}

\begin{lstlisting}[style=lolc,caption={Gravitations-Beispiel mittels kalman-clib},label=lst:kalman-clib]
/*!
* The formulas used are:
* s = s + v*T + g*0.5*T^2
* v = v + g*T
* g = g
*
* The time constant is set to T = 1s.
* The initial estimation of the gravity constant is set to 6 m/s^2.
*/

#include <assert.h>
#include "kalman_example_gravity.h"

// create the filter structure
#define KALMAN_NAME gravity
#define KALMAN_NUM_STATES 3
#define KALMAN_NUM_INPUTS 0
#include "kalman_factory_filter.h"

// create the measurement structure
#define KALMAN_MEASUREMENT_NAME position
#define KALMAN_NUM_MEASUREMENTS 1
#include "kalman_factory_measurement.h"

// clean up
#include "kalman_factory_cleanup.h"

/*!
* \brief Initializes the gravity Kalman filter
*/
static void kalman_gravity_init()
{
    /* initialize the filter structures */
    kalman_t *kf = kalman_filter_gravity_init();
    kalman_measurement_t *kfm = kalman_filter_gravity_measurement_position_init();

    /* set initial state */
    matrix_t *x = kalman_get_state_vector(kf);
    x->data[0] = 0; // s_i
    x->data[1] = 0; // v_i
    x->data[2] = 6; // g_i

    /* set state transition */
    matrix_t *A = kalman_get_state_transition(kf);
    
    /* set time constant */
    const matrix_data_t T = 1;

    /* transition of x to s */
    matrix_set(A, 0, 0, 1);   // 1
    matrix_set(A, 0, 1, T);   // T
    matrix_set(A, 0, 2, (matrix_data_t)0.5*T*T); // 0.5 * T^2
    
    /* transition of x to v */
    matrix_set(A, 1, 0, 0);   // 0
    matrix_set(A, 1, 1, 1);   // 1
    matrix_set(A, 1, 2, T);   // T

    /* transition of x to g */
    matrix_set(A, 2, 0, 0);   // 0
    matrix_set(A, 2, 1, 0);   // 0
    matrix_set(A, 2, 2, 1);   // 1

    /* set covariance */
    matrix_t *P = kalman_get_system_covariance(kf);

    matrix_set_symmetric(P, 0, 0, (matrix_data_t)0.1);   // var(s)
    matrix_set_symmetric(P, 0, 1, 0);   // cov(s,v)
    matrix_set_symmetric(P, 0, 2, 0);   // cov(s,g)

    matrix_set_symmetric(P, 1, 1, 1);   // var(v)
    matrix_set_symmetric(P, 1, 2, 0);   // cov(v,g)

    matrix_set_symmetric(P, 2, 2, 1);   // var(g)

    /* set measurement transformation */
    matrix_t *H = kalman_get_measurement_transformation(kfm);

    matrix_set(H, 0, 0, 1);     // z = 1*s 
    matrix_set(H, 0, 1, 0);     //   + 0*v
    matrix_set(H, 0, 2, 0);     //   + 0*g

    /* set process noise */
    matrix_t *R = kalman_get_process_noise(kfm);

    matrix_set(R, 0, 0, (matrix_data_t)0.5);     // var(s)
}

// define measurements.
//
// MATLAB source
// -------------
// s = s + v*T + g*0.5*T^2; 
// v = v + g*T;
#define MEAS_COUNT (15)
static matrix_data_t real_distance[MEAS_COUNT] = {
    (matrix_data_t)0,
    (matrix_data_t)4.905,
    /* ... snip ... */
    (matrix_data_t)828.94,
    (matrix_data_t)961.38 };

// define measurement noise with variance 0.5
//
// MATLAB source
// -------------
// noise = 0.5^2*randn(15,1);
static matrix_data_t measurement_error[MEAS_COUNT] = {
    (matrix_data_t)0.13442,
    /* ... snip ... */
    (matrix_data_t)-0.015764,
    (matrix_data_t)0.17869 };

/*!
* \brief Runs the gravity Kalman filter.
*/
void kalman_gravity_demo()
{
    // initialize the filter
    kalman_gravity_init();

    // fetch structures
    kalman_t *kf = &kalman_filter_gravity;
    kalman_measurement_t *kfm = &kalman_filter_gravity_measurement_position;

    matrix_t *x = kalman_get_state_vector(kf);
    matrix_t *z = kalman_get_measurement_vector(kfm);
    
    // filter!
    for (int i = 0; i < MEAS_COUNT; ++i)
    {
        // prediction.
        kalman_predict(kf);

        // measure ...
        matrix_data_t measurement = real_distance[i] + measurement_error[i];
        matrix_set(z, 0, 0, measurement);

        // update
        kalman_correct(kf, kfm);
    }

    // fetch estimated g
    matrix_data_t g_estimated = x->data[2];
    assert(g_estimated > 9 && g_estimated < 10);
}
\end{lstlisting}

\begin{lstlisting}[style=lolc,caption={Gravitations-Beispiel mittels libfixkalman},label=lst:libfixkalman]
/*!
* The formulas used are:
* s = s + v*T + g*0.5*T^2
* v = v + g*T
* g = g
*
* The time constant is set to T = 1s.
* The initial estimation of the gravity constant is set to 6 m/s^2.
*/

// no control inputs given, so _uc type used
kalman16_uc_t kf;

kalman16_observation_t kfm;

#define matrix_set(matrix, row, column, value) \
    matrix->data[row][column] = value

#define matrix_set_symmetric(matrix, row, column, value) \
    matrix->data[row][column] = value; \
    matrix->data[column][row] = value

/*!
* \brief Initializes the gravity Kalman filter
*/
static void kalman_gravity_init()
{
    /* initialize the filter structures */
    kalman_filter_initialize_uc(&kf, KALMAN_NUM_STATES);
    kalman_observation_initialize(&kfm, KALMAN_NUM_STATES, KALMAN_NUM_MEASUREMENTS);

    /* set initial state */
    mf16 *x = kalman_get_state_vector_uc(&kf);
    x->data[0][0] = 0; // s_i
    x->data[1][0] = 0; // v_i
    x->data[2][0] = fix16_from_float(6); // g_i

    /* set state transition */
    mf16 *A = kalman_get_state_transition_uc(&kf);
    
    /* set time constant */
    const fix16_t T = fix16_one;
    const fix16_t Tsquare = fix16_sq(T);

    /* helper */
    const fix16_t fix16_half = fix16_from_float(0.5);

    /* transition of x to s */
    matrix_set(A, 0, 0, fix16_one);   // 1
    matrix_set(A, 0, 1, T);   // T
    matrix_set(A, 0, 2, fix16_mul(fix16_half, Tsquare)); // 0.5 * T^2
    
    /* transition of x to v */
    matrix_set(A, 1, 0, 0);   // 0
    matrix_set(A, 1, 1, fix16_one);   // 1
    matrix_set(A, 1, 2, T);   // T

    /* transition of x to g */
    matrix_set(A, 2, 0, 0);   // 0
    matrix_set(A, 2, 1, 0);   // 0
    matrix_set(A, 2, 2, fix16_one);   // 1

    /* set covariance */
    mf16 *P = kalman_get_system_covariance_uc(&kf);

    matrix_set_symmetric(P, 0, 0, fix16_half);   // var(s)
    matrix_set_symmetric(P, 0, 1, 0);   // cov(s,v)
    matrix_set_symmetric(P, 0, 2, 0);   // cov(s,g)

    matrix_set_symmetric(P, 1, 1, fix16_one);   // var(v)
    matrix_set_symmetric(P, 1, 2, 0);   // cov(v,g)

    matrix_set_symmetric(P, 2, 2, fix16_one);   // var(g)

    /* set system process noise */
    mf16 *Q = kalman_get_system_process_noise_uc(&kf);
    mf16_fill(Q, F16(0.0001));

    /* set measurement transformation */
    mf16 *H = kalman_get_observation_transformation(&kfm);

    matrix_set(H, 0, 0, fix16_one);     // z = 1*s 
    matrix_set(H, 0, 1, 0);     //   + 0*v
    matrix_set(H, 0, 2, 0);     //   + 0*g

    /* set process noise */
    mf16 *R = kalman_get_observation_process_noise(&kfm);

    matrix_set(R, 0, 0, fix16_half);     // var(s)
}

// define measurements.
//
// MATLAB source
// -------------
// s = s + v*T + g*0.5*T^2; 
// v = v + g*T;
#define MEAS_COUNT (15)
static fix16_t real_distance[MEAS_COUNT] = {
    F16(4.905),
    /* ... snip ... */
    F16(961.38),
    F16(1103.6) };

// define measurement noise with variance 0.5
//
// MATLAB source
// -------------
// noise = 0.5^2*randn(15,1);
static fix16_t measurement_error[MEAS_COUNT] = {
    F16(0.13442),
    /* ... snip ... */
    F16(-0.015764),
    F16(0.17869) };

/*!
* \brief Runs the gravity Kalman filter.
*/
void kalman_gravity_demo()
{
    // initialize the filter
    kalman_gravity_init();

    mf16 *x = kalman_get_state_vector_uc(&kf);
    mf16 *z = kalman_get_observation_vector(&kfm);
    
    // filter!
    uint_fast16_t i;
    for (i = 0; i < MEAS_COUNT; ++i)
    {
        // prediction.
        kalman_predict_uc(&kf);

        // measure ...
        fix16_t measurement = fix16_add(real_distance[i], measurement_error[i]);
        matrix_set(z, 0, 0, measurement);

        // update
        kalman_correct_uc(&kf, &kfm);
    }

    // fetch estimated g
    const fix16_t g_estimated = x->data[2][0];
    const float value = fix16_to_float(g_estimated);
    assert(value > 9.7 && value < 10);
}
\end{lstlisting}

\begin{lstlisting}[style=lolc,caption={Fusion: \textsc{Euler}'sche Winkel aus \gls{dcm}},label=lst:libfixmath_dcm_euler]
void sensor_dcm2rpy(
	const mf16 *RESTRICT const dcm, 
	fix16_t *RESTRICT const roll, 
	fix16_t *RESTRICT const pitch, 
	fix16_t *RESTRICT const yaw)
{
    *pitch = -fix16_asin(dcm->data[0][2]);
    *roll  = fix16_atan2(dcm->data[1][2], dcm->data[2][2]);
    *yaw   = fix16_atan2(dcm->data[0][1], dcm->data[0][0]);
}
\end{lstlisting}

\begin{lstlisting}[style=lolc,caption={Fusion: Ermittlung des Quaternions aus den fusionierten Datem},label=lst:quaternion_from_kalman]
HOT NONNULL LEAF
static void fetch_quaternion_opt2(register qf16 *RESTRICT const quat)
{
	const register mf16 *const x2 = kalman_get_state_vector_uc(&kf_orientation);
	const register mf16 *const x3 = kalman_get_state_vector_uc(&kf_attitude);

	// m00 = R(1, 1);    m01 = R(1, 2);    m02 = R(1, 3);
	// m10 = R(2, 1);    m11 = R(2, 2);    m12 = R(2, 3);
	// m20 = R(3, 1);    m21 = R(3, 2);    m22 = R(3, 3);

	const fix16_t m10 = x2->data[0][0];
	const fix16_t m11 = x2->data[1][0];
	const fix16_t m12 = x2->data[2][0];

	const fix16_t m20 = -x3->data[0][0];
	const fix16_t m21 = -x3->data[1][0];
	const fix16_t m22 = -x3->data[2][0];

	// calculate cross product for C1
	// m0 = cross([m10 m11 m12], [m20 m21 m22])
	// -->
	//      m00 = m11*m22 - m12*m21
	//      m01 = m12*m20 - m10*m22
	//      m02 = m10*m21 - m11*m20
	fix16_t m00 = fix16_sub(fix16_mul(m11, m22), fix16_mul(m12, m21));
	fix16_t m01 = fix16_sub(fix16_mul(m12, m20), fix16_mul(m10, m22));
	fix16_t m02 = fix16_sub(fix16_mul(m10, m21), fix16_mul(m11, m20));

	// normalize C1 
	const register fix16_t norm = norm3(m00, m01, m02);
	m00 = fix16_div(m00, norm);
	m01 = fix16_div(m01, norm);
	m02 = fix16_div(m02, norm);

	// "Angel" code
	// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/

	fix16_t qw, qx, qy, qz;

	// check the matrice's trace
	const register fix16_t trace = fix16_add(m00, fix16_add(m11, m22));
	if (trace > 0)
	{
		/*
		s = 0.5 / sqrt(trace + 1.0);
		qw = 0.25 / s;
		qx = ( R(3,2) - R(2,3) ) * s;
		qy = ( R(1,3) - R(3,1) ) * s;
		qz = ( R(2,1) - R(1,2) ) * s;
		*/

		const fix16_t s = fix16_div(F16(0.5), fix16_sqrt(fix16_add(F16(1.0), trace)));

		qw = fix16_div(F16(0.25), s);
		qx = fix16_mul(fix16_sub(m21, m12), s);
		qy = fix16_mul(fix16_sub(m02, m20), s);
		qz = fix16_mul(fix16_sub(m10, m01), s);
	}
	else
	{
		if (m00 > m11 && m00 > m22)
		{
			/*
			s = 2.0 * sqrt( 1.0 + R(1,1) - R(2,2) - R(3,3));
			qw = (R(3,2) - R(2,3) ) / s;
			qx = 0.25 * s;
			qy = (R(1,2) + R(2,1) ) / s;
			qz = (R(1,3) + R(3,1) ) / s;
			*/
			const fix16_t s = fix16_mul(F16(2), fix16_sqrt(fix16_add(F16(1), fix16_sub(m00, fix16_add(m11, m22)))));

			qw = fix16_div(fix16_sub(m21, m12), s);
			qx = fix16_mul(F16(0.25), s);
			qy = fix16_div(fix16_add(m01, m10), s);
			qz = fix16_div(fix16_add(m02, m20), s);
		}
		else if (m11 > m22)
		{
			/*
			s = 2.0 * sqrt( 1.0 + R(2,2) - R(1,1) - R(3,3));
			qw = (R(1,3) - R(3,1) ) / s;
			qx = (R(1,2) + R(2,1) ) / s;
			qy = 0.25 * s;
			qz = (R(2,3) + R(3,2) ) / s;
			*/
			const fix16_t s = fix16_mul(F16(2), fix16_sqrt(fix16_add(F16(1), fix16_sub(m11, fix16_add(m00, m22)))));

			qw = fix16_div(fix16_sub(m02, m20), s);
			qx = fix16_div(fix16_add(m01, m10), s);
			qy = fix16_mul(F16(0.25), s);
			qz = fix16_div(fix16_add(m12, m21), s);
		}
		else
		{
			/*
			s = 2.0 * sqrt( 1.0 + R(3,3) - R(1,1) - R(2,2) );
			qw = (R(2,1) - R(1,2) ) / s;
			qx = (R(1,3) + R(3,1) ) / s;
			qy = (R(2,3) + R(3,2) ) / s;
			qz = 0.25 * s;
			*/
			const fix16_t s = fix16_mul(F16(2), fix16_sqrt(fix16_add(F16(1), fix16_sub(m22, fix16_add(m00, m11)))));

			qw = fix16_div(fix16_sub(m10, m01), s);
			qx = fix16_div(fix16_add(m02, m20), s);
			qy = fix16_div(fix16_add(m12, m21), s);
			qz = fix16_mul(F16(0.25), s);
		}
	}

	// compose quaternion
	quat->a = qw;
	quat->b = qx;
	quat->c = qy;
	quat->d = qz;

	// normalizify
	qf16_normalize(quat, quat);
}
\end{lstlisting}

\begin{lstlisting}[style=lolc,caption={Fusion: Berechnung des VorwÃ¤rtsvektors aus Magnetometer und Accelerometer},label=lst:magnetometer_project]
HOT LEAF NONNULL
STATIC_INLINE void magnetometer_project(
	fix16_t *RESTRICT const mx, 
	fix16_t *RESTRICT const my, 
	fix16_t *RESTRICT const mz)
{
	const mf16 *const x = kalman_get_state_vector_uc(&kf_attitude);

	register const fix16_t acc_x = x->data[0][0];
	register const fix16_t acc_y = x->data[1][0];
	register const fix16_t acc_z = x->data[2][0];

	/************************************************************************/
	/* Instead of tilt corrected magnetometer, use TRIAD algorithm          */
	/************************************************************************/

	// calculate cross product for C1
	// m = cross([m_magnetometer.x m_magnetometer.y m_magnetometer.z], [m_accelerometer.x m_accelerometer.y m_accelerometer.z])
	// -->
	//      mx = m_magnetometer.y*m_accelerometer.z - m_magnetometer.z*m_accelerometer.y
	//      my = m_magnetometer.z*m_accelerometer.x - m_magnetometer.x*m_accelerometer.z
	//      mz = m_magnetometer.x*m_accelerometer.y - m_magnetometer.y*m_accelerometer.x
	*mx = fix16_sub(fix16_mul(m_magnetometer.y, acc_z), fix16_mul(m_magnetometer.z, acc_y));
	*my = fix16_sub(fix16_mul(m_magnetometer.z, acc_x), fix16_mul(m_magnetometer.x, acc_z));
	*mz = fix16_sub(fix16_mul(m_magnetometer.x, acc_y), fix16_mul(m_magnetometer.y, acc_x));

	// normalize C1 
	const register fix16_t norm = norm3(*mx, *my, *mz);
	*mx = fix16_div(*mx, norm);
	*my = fix16_div(*my, norm);
	*mz = fix16_div(*mz, norm);
}
\end{lstlisting}

\begin{lstlisting}[style=lolc,caption={Fusion: Korrektur des \emph{orientation}-Filters mittels Magnetometer},label=lst:magnetometer_correct]
HOT
static void fusion_update_orientation(register const fix16_t deltaT)
{
	/************************************************************************/
	/* Calculate metrics required for update                                */
	/************************************************************************/
	fix16_t mx, my, mz;
	magnetometer_project(&mx, &my, &mz);
	
	/************************************************************************/
	/* Prepare noise                                                        */
	/************************************************************************/

	tune_measurement_noise(&kfm_magneto);
	{
		mf16 *const R = &kfm_magneto.R;

		// anyway, overwrite covariance of projection
		matrix_set(R, 0, 0, fix16_mul(initial_r_projection, alpha1));
		matrix_set(R, 1, 1, fix16_mul(initial_r_projection, alpha1));
		matrix_set(R, 2, 2, fix16_mul(initial_r_projection, alpha1));
	}

	/************************************************************************/
	/* Prepare measurement                                                  */
	/************************************************************************/
	{
		mf16 *const z = &kfm_magneto.z;

		matrix_set(z, 0, 0, mx);
		matrix_set(z, 1, 0, my);
		matrix_set(z, 2, 0, mz);

		matrix_set(z, 3, 0, kf_attitude.x.data[3][0]);
		matrix_set(z, 4, 0, kf_attitude.x.data[4][0]);
		matrix_set(z, 5, 0, kf_attitude.x.data[5][0]);
	}

	/************************************************************************/
	/* Perform Kalman update                                                */
	/************************************************************************/

	kalman_correct_uc(&kf_orientation, &kfm_magneto);

	/************************************************************************/
	/* Re-orthogonalize and update state matrix                             */
	/************************************************************************/

	fusion_sanitize_state(&kf_orientation);
}
\end{lstlisting}