\section{Integrierte Entwicklungsumgebungen}
Einige IDEs --- u.a. Keil MDK, CooCox CoIDE, IAR Embedded Workbench --- wurden zur Benutzung mit dem \gls{frdm-kl25z} ausprobiert, jedoch aus verschiedenen Gründen für nicht hilfreich befunden.
Zwei der Verwendeten IDEs --- Freescale CodeWarrior und Microsoft Visual Studio --- werden im folgenden kurz beschrieben.

\subsection{Freescale CodeWarrior}
\label{subsec:codewarrior}

Die CodeWarrior Development Studio ist eine von Freescale vertriebene, kommerzielle, Eclipse-basierte IDE zur Entwicklung von Firmware für Freescale-Controller (Abbildung~\ref{fig:codewarrior}).
Sie ist in der Variante der "`Special Edition"' bei einer Codegrößenbeschränkung von 64KiB (bei Verwendung von Chips der Kinetis-L-Serie) kostenlos verwendbar.
Ein Anheben der Codegröße auf maximal 128KiB (entspricht der Flash-Größe des \gls{kl25z}) erzwingt den Erwerb einer jährlich fälligen Lizenzgebühr um ca. \$400 (Stand: 2014).
Ein Debugger ist integriert, setzt jedoch die Verwendung eines spezifischen Programmers oder der P\&Emicro-Firmware für OpenSDA voraus (vgl. Abschnitt~\ref{sec:opensda}). Die Verwendung
von Breakpoints ist dabei auf die Anzahl der Hardware-Breakpoints des Cores limitiert.

\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.8\textwidth]{./images/codewarrior.png}
    \caption[CodeWarrior Development Studio]{CodeWarrior Development Studio}
    \label{fig:codewarrior}
\end{figure}


Integriert in die IDE ist Freescales \gls{Processor Expert}, ein Konfigurationstool und Treibergenerator für die Peripherie der Freescale-Controller (Abbildung~\ref{fig:processorexpert}). 
Anleitungen zum \gls{bare metal}-Betrieb der Controller sind spärlich gesät\footnote{Die von Freescale gelieferten Sample Code-Packages scheinen für alle IDEs außer CodeWarrior 
ausgelegt zu sein --- ihre Verwendung ist mehr als umständlich. Das Quick Start-Package hingegegn beinhaltet ausschließlich OpenSDA-Firmwares und ist für den Anfang zwar notwendig, 
hat mit einem schnellen Start jedoch wenig zu tun.}, als ein guter Anlaufpunkt für Anleitungen im Allgemeinen stellte sich die Seite \url{http://mcuoneclipse.com/} heraus.

\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.5\textwidth]{./images/generate-processor-expert-code.png}
    \caption[Processor Expert in CodeWarrior]{Processor Expert in CodeWarrior. Code-Generator und definierte Peripherie.\\Quelle: \url{http://mcuoneclipse.com}}
    \label{fig:processorexpert}
\end{figure}

\subsection{Microsoft Visual Studio mit SysProgs VisualGDB}

VisualGDB ist ein kommerzielles Add-On für Microsoft Visual Studio und ermöglicht die Entwicklung und das Debugging von embedded- und Linuxapplikationen (auch natives Android) unter Windows. 
Neben einem \gls{gdb}-Server stellt es Vorlagen und Konfigurationsdateien für verschiedene Systeme und Microcontroller zur Verfügung, so unter anderem für
die STM32-Serie von STMicroelectronics, die Kinetis-Serie von Freescale, sowie einige AVR-Prozessoren. Durch die Verwendung der freien \texttt{arm-gcc}-Toolchain
existieren keine Codegrößenbeschränkungen und der volle Funktionsumfang der Visual Studio-IDE kann für die Entwicklung verwendet werden. 

VisualGDB wurde in der weiteren Entwicklung des Projektes in Kombination mit der Segger J-Link-Firmware aufgrund deren "`unlimited breakpoint"'-Feature genutzt, 
um einen schnellen Entwicklungsprozess zu ermöglichen.  Bei der Konfiguration ist dabei darauf zu achten, den Chip im \gls{swd}-Modus (d.h. \emph{nicht} 
im \gls{JTAG}-Modus) anzusprechen.

Wie in Abb.~\ref{fig:visualgdb_programmer} ersichtlich, wäre die Verwendung der \gls{OpenOCD}-Firmware ebenfalls
theoretisch möglich, zum Zeitpunkt der Entwicklung lagen jedoch keine \gls{OpenOCD}-Konfigurationsdateien für Freescale-Boards vor.

Eine Hürde bei der C-Entwicklung mit Visual Studio kann dabei der msvc-Compiler darstellen, da dieser bis einschließlich Visual Studio 2012 den C99-Standard 
nicht\footnote{Siehe http://herbsutter.com/2012/05/03/reader-qa-what-about-vc-and-c99/} unterstützt. Einen Workaround dafür stellt die Kompilierung im 
C++-Modus dar. Dies ist jedoch nur bei der Prototypen-Entwicklung (ohne VisualGDB) ein Ärgernis, da zur Compilierung für das Embedded-Target der arm-gcc-Compiler 
verwendet wird. Dieser lag zum Zeitpunkt der Entwicklung in der Version 4.8.2 vor, wodurch die Verwendung von C++11-Features möglich wäre; Hierauf wurde 
während der Entwicklung jedoch verzichtet. Ferner muss man sich an den Verzicht einiger IntelliSense-Funktionen gewöhnen, da dieses die gcc-spezifischen
(und C99-spezifischen) Befehle nicht erkennt und in der Folge (ungültige) Fehler listet.

Ein Tutorial zur Nutzung von VisualGDB mit dem FRDM-KL25Z findet sich unter \url{http://visualgdb.com/tutorials/arm/kinetis/kl25z-rgb-led/}.

\begin{figure}[htbp]
		\centering
		\includegraphics[width=\textwidth]{./images/visualgdb_project.png}
    \caption{VisualGDB: Auswahl des Controllers}
    \label{fig:visualgdb_controller}
\end{figure}

\begin{figure}[htbp]
		\centering
		\includegraphics[width=\textwidth]{./images/visualgdb_programmer.png}
    \caption{VisualGDB: Auswahl des Programmers}
    \label{fig:visualgdb_programmer}
\end{figure}

\begin{figure}[htbp]
		\centering
		\includegraphics[width=\textwidth]{./images/visualgd_makefile.png}
    \caption{VisualGDB: Make-Optionen}
    \label{fig:visualgd_makefile}
\end{figure}
