\setpartpreamble[u, r][6cm]{Dies ist ein Beispiel für eine Part-Präambel.}
\part[]{Entwicklungsumgebung}
\chapter{Entwicklungsumgebung}

\section{Freescale FRDM-KL25Z}

Das \gls{frdm-kl25z} ist ein Evaluationsboard für die \gls{kl25z}-Serie \glspl{mcu} von Freescale, welche auf dem 
ARM \gls{cortex-m0+}-Core basiert. Alle Controller der Kinetis L-Serie sind für mixed-signal-Anwendungen geeignet und bis 48 MHz taktbar.
Das Board besitzt neben 54 \glspl{gpio}, einen USB-Controller, eine RGB-LED, einen kapazitiven Touch-Bereich, 
sowie einen Freescale MMA8451Q-Accelerometer (vgl. Abbildung~\ref{fig:kl25z}); Letzterer wird in Abschnitt~\ref{sec:mma8451q} auf
Seite~\pageref{sec:mma8451q} noch einmal erweiternd besprochen.
Nicht zuletzt trug auch der geringen Preis des Boards von ca. 12 EUR zur Kaufentscheidung bei. 
Freescale bietet ebenfalls ein etwas teureres Board --- das seit 2013 verfügbare FRDM-KL26Z\footnote{\cite{fs_howlong}} --- 
für den KL26Z (MKL26Z128VLH4) an, welches zusätzlich zu einem Accelerometer einen Gyrosensor 
(in Form der FXOS87000CQ-\gls{imu}), sowie einen zusätzlichen Lichtsensor bietet. 
Es ist jedoch zu beachten, dass hierbei 17 \glspl{gpio} auf den Evaluationboard entfallen (\citealp{kl26z_qsg}).

\subsection{Features}

Der \gls{kl25z} ordnet sich im Mittelfeld zwischen den Varianten KL0 (16-48pin, 8-32KB), KL1x (32-80pin, 32-256KB), 
KL3x (64-121pin, 64-256KB, Segment-LCD) und KL4x (64-121pin, 128-256KB, USB + Segment-LCD) ein. Eine kurze Übersicht der Konfiguration
des \gls{frdm-kl25z} ist in der folgenden Auflistung\footnote{Dem mbed-Projekt (\url{www.mbed.org}) entnommen.} gegeben.

\begin{itemize}
	\item Freescale KL25Z Kinetis KL2 MCU (MKL25Z128VLK4)
	\begin{itemize}
		\item High performance ARM® Cortex™-M0+ Core
		\item 48MHz, 16KB RAM, 128KB FLASH
		\item 2xSPI, 2xI2C, 3xUART, 6xPWM, 6xADC, Touchsensor, \gls{gpio}
	\end{itemize}
	\item FRDM-KL25Z Onboard-Peripherie
	\begin{itemize}
		\item MMA8451Q - 3-Achsen-Accelerometer
		\item PWM-gesteuerte RGB LED
		\item Kapazitiver Touchsensor
	\end{itemize}
	\item Board-Formfaktor
	\begin{itemize}
		\item 81mm x 53mm
		\item 5V USB oder 4.5-9V supply
		\item Eingebauter USB drag'n'drop FLASH programmer (austauschbar)
	\end{itemize}
\end{itemize}

Die von Freescale verwendete Parametrierung des ARM-Cores kann Tabelle~\ref{tab:core-configuration} entnommen werden. 
Es ist hierbei hervorzuheben, dass man sich sowohl für einen single-cycle-Multiplier (anstelle des alternativen 32-cycle-Multipliers), 
als auch für single-cycle-Zugriff auf die \glspl{gpio} (über einen speziellen Addressraum) entschieden hat, was den Chip
trotz der Ansiedlung am unteren Performanceende der \gls{Cortex}-Varianten für Signalverarbeitungsprobleme interessant macht.

\begin{table}
\begin{tabularx}{\textwidth}{llX} 
\toprule
	\multicolumn{3}{l}{Konfiguration der ARM Cortex-M0+-Cores}\\  
\midrule 
	Parameter & Wert & Beschreibung \\ 
\midrule 
	Arch Clock Gating  & 1 = Present & Implements architectural clock gating \\
	DAP Slave Port Support & 1 & Support any AHB debug access port (like the CM4 DAP) \\
	DAP ROM Table Base & \texttt{0xF000\_2003} & Base address for DAP ROM table \\
	Endianess & 0 & Little endian control for data transfers \\
	Breakpoints & 2 & Implements 2 breakpoints \\
	Debug Support & 1 = Present & \\
	Halt Event Support & 1 = Present & \\
	I/O Port & 1 = Present & Implements single-cycle ld/st accesses to special addr space  \\
	IRQ Mask Enable & \texttt{0x00000000} & Assume (for now) all 32 IRQs are used (set if IRQ is disabled) \\
	Debug Port Protocol & 0 = SWD & SWD protocol, not JTAG \\
	Core Memory Protection & 0 = Absent & No MPU \\
	Number of IRQs & 32 & Assume full NVIC request vector \\
	Reset all regs & 0 = Standard & Do not force all registers to be async reset \\
	Multiplier & 0 = Fast Mul & Implements single-cycle multiplier \\
	Multi-drop Support & 0 = Absent & Do not include serial wire support for multi-drop \\
	System Tick Timer & 1 = Present & Implements system tick timer (for CM4 compatibility) \\
	DAP Target ID & 0 & \\
	User/Privileged & 1 = Present & Implements processor operating modes \\
	Vector Table Offset Register & 1 = Present & Implements relocation of exception vector table \\
	WIC Support & 1 = Present & Implements WIC interface \\
	WIC Requests & 34 & Exact number of wakeup IRQs is 34 \\
	Watchpoints & 2 & Implements 2 watchpoints \\
\bottomrule
\end{tabularx}
\caption[Konfiguration der ARM Cortex-M0+-Cores]{Konfiguration der ARM Cortex-M0+-Cores (\citealp{kl25z_sfrm})}
\label{tab:core-configuration}
\end{table}

\begin{figure}[htbp]
	\centering
	\begin{subfigure}[b]{0.4\textwidth}
		\centering
		\includegraphics[width=\textwidth]{./images/kl25z.jpg}
		\caption[Board]{Board \\Quelle: Freescale}
	\end{subfigure}%
	\quad
	\begin{subfigure}[b]{0.5\textwidth}
		\centering
		\includegraphics[width=\textwidth]{./images/kl25z-pinout.jpg}
		\caption[Pinout]{Pinout \\Quelle: mbed}
	\end{subfigure}
	
	\caption[Freescale FRDM-KL25Z]{Freescale FRDM-KL25Z}
	\label{fig:kl25z}
\end{figure}

\subsection{On-Chip-Programmer/Debugger}

Auf jedem Freescale Freedom-Entwicklungsboard ist ein \gls{ocd} verbaut, welcher zusätzlich zum Debugging die 
Fähigkeit besitzt, die \gls{mcu} zu programmieren. Freescale nennt diese Einheit \gls{OpenSDA} 
(ganz im Sinne der "`Freedom"'-Benamung der Boards), die zwar entgegen ihres Namens proprietärer Natur ist, jedoch die 
zusätzliche Beschaffung eines externen Programmers erspart. 
Auf diesen wird in Abschnitt~\ref{sec:opensda} noch einmal eingegangen.

\subsection{Bit Manipulation Engine}

Der \gls{kl25z} bietet zusätzlich zum single-cycle-I/O eine \gls{bme} genannte Einheit (\citealp{fs_howlong}), welche eine Variation 
des sog. \glslink{bit banding}{bit-bandings} (Abbildung~\ref{fig:bit-banding}) darstellt, wie sie in den \gls{Cortex}-M3 und -M4-Cores zur Verfügung steht.
Diese ermöglicht es, in nur einem Taktzyklus Operationen wie Setzen, Löschen und Invertieren (\texttt{AND}, \texttt{OR}, \texttt{XOR}, \gls{bfi}) 
auf einzelnen oder mehreren Bits einer Speicheradresse,
sowie atomares Beziehen und Setzen (\gls{lac}, \gls{las}, \gls{ubfx}) durchzuführen. Da hierbei die sonst notwendigen
fetch-Instruktionen entfallen, werden diese Befehle --- je nach Art --- in etwa der halben der sonst notwendigen Zeit (bzw. Instruktionszahl) ausgeführt. 
Ein Beispiel zur Verwendung der \gls{bme} kann in Listing~\ref{lst:bme-xor} gefunden werden.

Entsprechend dem \gls{cmsis} stellt Freescale Treiber zur Verfügung, welche Teile dieser Funktionalitäten in Form der sog. Fast-Port-Register (IOPORT-Register des Cores) 
zur Verfügung stellen. In Listing~\ref{lst:bme-set-clear} kann das Setzen und Löschen der Pins BTB8 und PTB9 nachvollzogen werden.

\begin{lstlisting}[style=lolc,caption={Bit Manipulation Engine: Set und Clear mittels \gls{cmsis}-Treiber},label=lst:bme-set-clear]
/* regulaerer GPIO (mittels BME) */
PTB_BASE_PTR->PSOR  = 1 << 8; /*   set output register pin 8 */
PTB_BASE_PTR->PCOR  = 1 << 9; /* clear output register pin 9 */

/* Fast-GPIO (mittels BME) */
FPTB_BASE_PTR->PSOR = 1 << 8; /*   set output register pin 8 */
FPTB_BASE_PTR->PCOR = 1 << 9; /* clear output register pin 9 */
\end{lstlisting}

\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.8\textwidth]{./images/bit_banding.png}
    \caption[Bit-Banding]{Bit-Banding im \gls{Cortex}-M3\\Quelle: ARM}
    \label{fig:bit-banding}
\end{figure}

\subsection{$48 \mega\hertz$ mit dem Multi-Purpose Clock Generator}

Eine Schwierigkeit bei der Nutzung des \gls{kl25z} stellt die Komplexität des \gls{mcg} dar. Zur Initialisierung wurde der vom \gls{Processor Expert} (siehe Abschnitt~\ref{subsec:codewarrior})
erzeugte Code\footnote{Zu finden in Listing~\ref{lst:kl25z-pll-init}} verwendet und wie in Listing~\ref{lst:kl25z-pll-init-call} entnehmbar betrieben, um von der internen Referenzclock (\gls{fei})
auf den \gls{pee}-Modus mit $48 \mega\hertz$ zu wechseln\footnote{Hilfreich war das unter \url{https://www.youtube.com/watch?v=uiSTB4jkxhw} zu findende Video.}.

\begin{lstlisting}[style=lolc,caption={KL25Z: Aktivierung des 48MHz-\gls{pll}-Modus des \gls{mcg}},label=lst:kl25z-pll-init-call]
// - core and platform clock are required to have 48 MHz or less
// - for PBE (PLL engaged external) mode, xtal/divider must be in range 2..4 MHz

const int xtal = XTAL_FREQ;                  /* FRDM-KL25Z hat einen 8 MHz xtal on-board */
const int8_t divider = XTAL_PEE_DIVIDE;      /* Division durch 4 (8 MHz --> 2 MHz) */
const int8_t multiplier = XTAL_PEE_UPSCALE;  /* Skalierung mit 24 (2 MHz --> 48 MHz) */

pll_init(xtal, LOW_POWER /* = 0 */, CRYSTAL /* = 1 */, divider, multiplier, MCGOUT /* = 1 */);
\end{lstlisting}

Eine Übersicht der Clock-Einheit und der \gls{mcg}-Modi findet sich in den Abbildungen~\ref{fig:kl25z-clocking}, \ref{fig:kl25z-mcg} und~\ref{fig:kl25z-mcg-states}.

\section{Freescale OpenSDA}
\label{sec:opensda}

Der \gls{OpenSDA}-Chip auf dem  kommuniziert dabei mit der im \gls{Cortex}-Kern integrierten \gls{CoreSight}-Einheit über das \gls{JTAG}-Protokoll.
Der Chip selbst kann dabei mit einer alternativen Firmware geflasht werden (vgl. Abb. \ref{fig:opensda-block}), welche eine spezialisierte 
(d.h. treiberspezifische) Ansteuerung der \gls{CoreSight}-Einheit ermöglicht.

\begin{figure}[htbp]
		\centering
		\includegraphics{./images/opensda-block-diagram.png}
    \caption[OpenSDA-Blockdiagramm]{OpenSDA-Blockdiagramm\\Quelle: \texttt{http://mcuoneclipse.com}}
    \label{fig:opensda-block}
\end{figure}

Die Standard-Firmware (PEmicro OpenSDA MSD) repräsentiert sich dabei nach dem Verbinden mit dem USB-Host als \gls{msd} und ist in der Lage, die \gls{mcu}
durch einfaches Drag \& Drop einer \gls{elf}-Datei programmiert werden. Debugging-Funktionalität bietet dieses Interface jedoch nicht, wodurch der
erste Schritt der Inbetriebnahme in den meisten Fällen darin bestehen wird, eine alternative Firmware (z.B. PEmicro OpenSDA DEBUG) zu flashen. Hierdurch
verliert man zwar die Funktionalität des USB-\gls{msd} und ist somit auf eine Programmersoftware angewiesen, diese ist jedoch z.B. in Form der Toolchain
der Freescale CodeWarrior-IDE (siehe Abschnitt~\ref{subsec:codewarrior} auf Seite~\pageref{subsec:codewarrior}) gegeben.

Eine Gegenüberstellung der alternativen SDA-Firmwares ohne Anspruch auf Vollständigkeit kann Tabelle \ref{tab:opensda-options} entnommen werden.

\begin{table}
\begin{tabular}{lllll} 
\toprule
\multicolumn{5}{l}{Gegenüberstellung von OpenSDA-Firmwares}\\  
\midrule 
Name & Art & Breakpoints & UART & MSD \\ 
\midrule 
PEmicro MSD OpenSDA & proprietär & (kein Debugging) & ja & ja\\
PEmicro DEBUG OpenSDA & proprietär & hardware & ja & nein \\
CMSIS-DAP & open source & hardware & nein & nein \\
Segger J-Link & proprietär & unbegrenzt & nein & nein \\ 
\bottomrule
\end{tabular}
\caption{Gegenüberstellung von OpenSDA-Firmwares}
\label{tab:opensda-options}
\end{table}

\subsection{OpenSDA unter Windows 8.1}
\label{subsec:opensda_windows8.1}

Beachtet werden muss, dass die \gls{msd}-Schnittstelle der \gls{OpenSDA}-Firmware unter Windows 8.1 nicht korrekt funktioniert! Dies ist der strengeren Handhabung
der USB Device-Deskriptoren unter der neueren Windows-Version geschuldet, wodurch die Antwort der OpenSDA-Firmware abgelehnt wird, was zu abbrechenden
Dateitransfers und damit fehlerhaft geflashter Firmware führt.

Um den \gls{msd}-Modus zum Programmieren zu verwenden oder die Firmware selbst umzuflashen muss demnach wahlweise Windows 7 oder niedriger oder ein Linux-basiertes System
verwendet werden, um das Laufwerk zu mounten. Die Verwendung einer virtuellen Maschine zum umprogrammieren der \gls{OpenSDA}-Firmware wurde versucht,
verlief jedoch aufgrund der Handhabung des USB-redirects erfolglos.

Eine Beschreibung des Vorgehens zur Umprogrammierung des \gls{OpenSDA}-Chips unter Linux ist in Anhang~\ref{chap:opensda_linux} gegeben.

\subsection{CMSIS-DAP}

Eine alternative (und quelloffene) Firmware für den \gls{OpenSDA}-Chip ist die \gls{cmsis-dap}-Firmware. Diese wird unter anderem für das \gls{mbed}-Projekt, 
sowie für die Interaktion mit dem \gls{OpenOCD}-Programmer/Debugger verwendet.

\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.8\textwidth]{./images/cmsis_dap_interface.png}
    \caption[CMSIS-DAP]{CMSIS-DAP\\Quelle: \url{http://nimblemachines.com/cmsis-dap/}}
    \label{fig:cmsis-dap}
\end{figure}


\subsection{Segger J-Link}

Weiterhin stellt auch Segger eine \gls{OpenSDA}-Variante seines proprietären J-Link-Programmers/Debuggers zur Verfügung. Einer der wesentlichen Vorteile dieser
Variante besteht in der hohen Programmiergeschwindigkeit, sowie der Unterstützung beliebig vieler Breakpoints über die Anzahl an Hardware-Breakpoints des Cores hinaus,
sofern die Lizenzbedingungen (Entwicklung nur für nichtkommerzielle Produkte und auf Freescale-\glspl{mcu}s auf Evaluation-Boards).

\section{Integrierte Entwicklungsumgebungen}

\subsection{Freescale CodeWarrior}
\label{subsec:codewarrior}

\todo{Erwähnung von Processor Expert}

\lipsum[3]

\subsection{Microsoft Visual Studio mit SysProgs VisualGDB}

VisualGDB ist ein kommerzielles Add-On für Microsoft Visual Studio und ermöglicht die Entwicklung und das Debugging von embedded- und Linuxapplikationen unter Windows. 
Neben einem \gls{gdb}-Server stellt es Vorlagen und Konfigurationsdateien für verschiedene Systeme und Microcontroller zur Verfügung, so unter anderem für
die STM32-Serie von STMicroelectronics, die Kinetis-Serie von Freescale, sowie einige AVR-Prozessoren. Durch die Verwendung der freien \texttt{arm-gcc}-Toolchain
existieren keine Codegrößenbeschränkungen und der volle Funktionsumfang der Visual Studio-IDE kann für die Entwicklung verwendet werden. 

VisualGDB wurde in der weiteren Entwicklung des Projektes in Kombination mit der Segger J-Link-Firmware aufgrund deren "`unlimited breakpoint"'-Feature genutzt, 
um einen schnellen Entwicklungsprozess zu ermöglichen.  Bei der Konfiguration ist dabei darauf zu achten, den Chip im \gls{swd}-Modus (d.h. \emph{nicht} 
im \gls{JTAG}-Modus) anzusprechen.

Wie in Abb.~\ref{fig:visualgdb_programmer} ersichtlich, wäre die Verwendung der \gls{OpenOCD}-Firmware ebenfalls
theoretisch möglich, zum Zeitpunkt der Entwicklung lagen jedoch keine \gls{OpenOCD}-Konfigurationsdateien für Freescale-Boards vor.

Eine Hürde bei der C-Entwicklung mit Visual Studio kann dabei der msvc-Compiler darstellen, da dieser bis einschließlich Visual Studio 2012 den C99-Standard 
nicht\footnote{Siehe http://herbsutter.com/2012/05/03/reader-qa-what-about-vc-and-c99/} unterstützt. Einen Workaround dafür stellt die Kompilierung im 
C++-Modus dar. Dies ist jedoch nur bei der Prototypen-Entwicklung (ohne VisualGDB) ein Ärgernis, da zur Compilierung für das Embedded-Target der arm-gcc-Compiler 
verwendet wird. Dieser lag zum Zeitpunkt der Entwicklung in der Version 4.8.2 vor, wodurch die Verwendung von C++11-Features möglich wäre; Hierauf wurde 
während der Entwicklung jedoch verzichtet. Ferner muss man sich an den Verzicht einiger IntelliSense-Funktionen gewöhnen, da dieses die gcc-spezifischen
(und C99-spezifischen) Befehle nicht erkennt und in der Folge (ungültige) Fehler listet.

Ein Tutorial zur Nutzung von VisualGDB mit dem FRDM-KL25Z findet sich unter \url{http://visualgdb.com/tutorials/arm/kinetis/kl25z-rgb-led/}.

\begin{figure}[htbp]
		\centering
		\includegraphics[width=\textwidth]{./images/visualgdb_project.png}
    \caption{VisualGDB: Auswahl des Controllers}
    \label{fig:visualgdb_controller}
\end{figure}

\begin{figure}[htbp]
		\centering
		\includegraphics[width=\textwidth]{./images/visualgdb_programmer.png}
    \caption{VisualGDB: Auswahl des Programmers}
    \label{fig:visualgdb_programmer}
\end{figure}

\begin{figure}[htbp]
		\centering
		\includegraphics[width=\textwidth]{./images/visualgd_makefile.png}
    \caption{VisualGDB: Make-Optionen}
    \label{fig:visualgd_makefile}
\end{figure}
