%\setpartpreamble[Position][Breite]{Text}
\setpartpreamble[u, r][6cm]{Dies ist ein Beispiel für eine Part-Präambel.}
\part[]{Entwicklungsumgebung}
\chapter{Entwicklungsumgebung}

\section{Freescale Kinetis KL25Z}

Auf jedem Freescale Freedom-Entwicklungsboard wie dem \gls{frdm-kl25z} ist außerdem ein \gls{ocd} verbaut, welcher zusätzlich zum Debugging die 
Fähigkeit besitzt, die \gls{mcu} zu programmieren. Freescale nennt diese Einheit \gls{OpenSDA} (ganz im Sinne der "`Freedom"'-Benamung der Boards), 
die zwar entgegen ihres Namens proprietärer Natur ist, jedoch die zusätzliche Beschaffung eines externen Programmers erspart.

\section{Freescale OpenSDA}

Der \gls{OpenSDA}-Chip auf dem  kommuniziert dabei mit der im \gls{Cortex}-Kern integrierten \gls{CoreSight}-Einheit über das \gls{JTAG}-Protokoll.
Der Chip selbst kann dabei mit einer alternativen Firmware geflasht werden (vgl. Abb. \ref{fig:opensda-block}), welche eine spezialisierte 
(d.h. treiberspezifische) Ansteuerung der \gls{CoreSight}-Einheit ermöglicht.

\begin{figure}[htbp]
		\centering
		\includegraphics{./images/opensda-block-diagram.png}
    \caption[OpenSDA-Blockdiagramm]{OpenSDA-Blockdiagramm}
		Quelle: \texttt{http://mcuoneclipse.com/2012/09/20/opensda-on-the-freedom-kl25z-board/}
    \label{fig:opensda-block}
\end{figure}

Die Standard-Firmware (PEmicro OpenSDA MSD) repräsentiert sich dabei nach dem Verbinden mit dem USB-Host als \gls{msd} und ist in der Lage, die \gls{mcu}
durch einfaches Drag \& Drop einer \gls{elf}-Datei programmiert werden. Debugging-Funktionalität bietet dieses Interface jedoch nicht, wodurch der
erste Schritt der Inbetriebnahme in den meisten Fällen darin bestehen wird, eine alternative Firmware (z.B. PEmicro OpenSDA DEBUG) zu flashen. Hierdurch
verliert man zwar die Funktionalität des USB-\gls{msd} und ist somit auf eine Programmersoftware angewiesen, diese ist jedoch z.B. in Form der Toolchain
der Freescale CodeWarrior-IDE (siehe Abschnitt~\ref{subsec:codewarrior} auf Seite~\pageref{subsec:codewarrior}) gegeben.

Eine Gegenüberstellung der alternativen SDA-Firmwares ohne Anspruch auf Vollständigkeit kann Tabelle \ref{tab:opensda-options} entnommen werden.

\begin{table}
\begin{tabular}{lllll} 
\toprule
Gegenüberstellung von OpenSDA-Firmwares\\  
\midrule 
Name & Art & Breakpoints & UART & MSD \\ 
\midrule 
PEmicro MSD OpenSDA & proprietär & (kein Debugging) & ja & ja\\
PEmicro DEBUG OpenSDA & proprietär & hardware & ja & nein \\
CMSIS-DAP & open source & hardware & nein & nein \\
Segger J-Link & proprietär & unbegrenzt & nein & nein \\ 
\bottomrule
\end{tabular}
\caption{Gegenüberstellung von OpenSDA-Firmwares}
\label{tab:opensda-options}
\end{table}

\subsection{OpenSDA unter Windows 8.1}
\label{subsec:opensda_windows8.1}

Beachtet werden muss, dass die \gls{msd}-Schnittstelle der \gls{OpenSDA}-Firmware unter Windows 8.1 nicht korrekt funktioniert! Dies ist der strengeren Handhabung
der USB Device-Deskriptoren unter der neueren Windows-Version geschuldet, wodurch die Antwort der OpenSDA-Firmware abgelehnt wird, was zu abbrechenden
Dateitransfers und damit fehlerhaft geflashter Firmware führt.

Um den \gls{msd}-Modus zum Programmieren zu verwenden oder die Firmware selbst umzuflashen muss demnach wahlweise Windows 7 oder niedriger oder ein Linux-basiertes System
verwendet werden, um das Laufwerk zu mounten. Die Verwendung einer virtuellen Maschine zum umprogrammieren der \gls{OpenSDA}-Firmware wurde versucht,
verlief jedoch aufgrund der Handhabung des USB-redirects erfolglos.

Eine Beschreibung des Vorgehens zur umprogrammierung des \gls{OpenSDA}-Chips unter Linux ist in Anhang~\ref{chap:opensda_linux} gegeben.

\subsection{CMSIS-DAP}

Eine alternative (und quelloffene) Firmware für den \gls{OpenSDA}-Chip ist die \gls{cmsis-dap}-Firmware. Diese wird unter anderem für das \gls{mbed}-Projekt, 
sowie für die Interaktion mit dem \gls{OpenOCD}-Programmer/Debugger verwendet.

\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.8\textwidth]{./images/cmsis_dap_interface.png}
    \caption[CMSIS-DAP]{CMSIS-DAP}
		Quelle: \texttt{http://nimblemachines.com/cmsis-dap/}
    \label{fig:cmsis-dap}
\end{figure}


\subsection{Segger J-Link}

Weiterhin stellt auch Segger eine \gls{OpenSDA}-Variante seines proprietären J-Link-Programmers/Debuggers zur Verfügung. Einer der wesentlichen Vorteile dieser
Variante besteht in der hohen Programmiergeschwindigkeit, sowie der Unterstützung beliebig vieler Breakpoints über die Anzahl an Hardware-Breakpoints des Cores hinaus,
sofern die Lizenzbedingungen (Entwicklung nur für nichtkommerzielle Produkte und auf Freescale-\glspl{mcu}s auf Evaluation-Boards).

\section{Integrierte Entwicklungsumgebungen}

\subsection{Freescale CodeWarrior}
\label{subsec:codewarrior}

\lipsum[3]

\subsection{Microsoft Visual Studio mit SysProgs VisualGDB}

VisualGDB ist ein kommerzielles Add-On für Microsoft Visual Studio und ermöglicht die Entwicklung und das Debugging von embedded- und Linuxapplikationen unter Windows. 
Neben einem \gls{gdb}-Server stellt es Vorlagen und Konfigurationsdateien für verschiedene Systeme und Microcontroller zur Verfügung, so unter anderem für
die STM32-Serie von STMicroelectronics, die Kinetis-Serie von Freescale, sowie einige AVR-Prozessoren. Durch die Verwendung der freien \texttt{arm-gcc}-Toolchain
existieren keine Codegrößenbeschränkungen und der volle Funktionsumfang der Visual Studio-IDE kann für die Entwicklung verwendet werden. 

VisualGDB wurde in der weiteren Entwicklung des Projektes in Kombination mit der Segger J-Link-Firmware aufgrund deren "`unlimited breakpoint"'-Feature genutzt, 
um einen schnellen Entwicklungsprozess zu ermöglichen.  Bei der Konfiguration ist dabei darauf zu achten, den Chip im \gls{swd}-Modus (d.h. \emph{nicht} 
im \gls{JTAG}-Modus) anzusprechen.

Wie in Abb.~\ref{fig:visualgdb_programmer} ersichtlich, wäre die Verwendung der \gls{OpenOCD}-Firmware ebenfalls
theoretisch möglich, zum Zeitpunkt der Entwicklung lagen jedoch keine \gls{OpenOCD}-Konfigurationsdateien für Freescale-Boards vor.

Eine Hürde bei der C-Entwicklung mit Visual Studio kann dabei der msvc-Compiler darstellen, da dieser bis einschließlich Visual Studio 2012 den C99-Standard 
nicht\footnote{Siehe http://herbsutter.com/2012/05/03/reader-qa-what-about-vc-and-c99/} unterstützt. Einen Workaround dafür stellt die Kompilierung im 
C++-Modus dar. Dies ist jedoch nur bei der Prototypen-Entwicklung (ohne VisualGDB) ein Ärgernis, da zur Compilierung für das Embedded-Target der arm-gcc-Compiler 
verwendet wird. Dieser lag zum Zeitpunkt der Entwicklung in der Version 4.8.2 vor, wodurch die Verwendung von C++11-Features möglich wäre; Hierauf wurde 
während der Entwicklung jedoch verzichtet.

\begin{figure}[htbp]
		\centering
		\includegraphics[width=\textwidth]{./images/visualgdb_project.png}
    \caption{VisualGDB: Auswahl des Controllers}
    \label{fig:visualgdb_controller}
\end{figure}

\begin{figure}[htbp]
		\centering
		\includegraphics[width=\textwidth]{./images/visualgdb_programmer.png}
    \caption{VisualGDB: Auswahl des Programmers}
    \label{fig:visualgdb_programmer}
\end{figure}

\begin{figure}[htbp]
		\centering
		\includegraphics[width=\textwidth]{./images/visualgd_makefile.png}
    \caption{VisualGDB: Make-Optionen}
    \label{fig:visualgd_makefile}
\end{figure}
