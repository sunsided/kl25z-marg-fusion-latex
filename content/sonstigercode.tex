\chapter{Serielle Kommunikation}

\section{Serielle Übertragung}

\subsection{Streamingmodi}
\label{subsec:streamingmodi}

Die Firmware ist in der Lage, Sensor- und Fusionsdaten in verschiedenen Modi über die serielle Schnittstelle auszugeben. Zur Aktivierung dieser Modi siehe Abschnitt~\ref{subsubsec:transmission_host_to_client}.

\subsubsection{Sensorrohdaten (Modus 0)}

Im Rohdatenmodus (Prefix \emph{0\textsubscript{dec}}) werden die ungefilterten Sensordaten des MPU6050-Accelerometers, sowie des HMC5883L-Magnetometers übertragen. Zur Unterstützung der Verarbeitung
und um Unabhängigkeit von der Konfiguration zu erreichen, werden die Daten konvertiert in das \gls{q16}-Format übertragen.

\begin{bytefield}[bitwidth=1.2em]{25}
	\bitheader{0-24} \\
	\colorbitbox{lightgreen}{1}{0} & 
	\bitbox{4}{A\textsubscript{x}} & \bitbox{4}{A\textsubscript{y}} & \bitbox{4}{A\textsubscript{z}} &
	\bitbox{4}{M\textsubscript{x}} & \bitbox{4}{M\textsubscript{y}} & \bitbox{4}{M\textsubscript{z}}% \\
	%\bitbox[t]{1}{} & \bitbox[t]{6}{$\underbrace{\hspace{6.6em}}_{\text{\normalsize Accelerometer}}$} & \bitbox[t]{6}{$\underbrace{\hspace{6.6em}}_{\text{\normalsize Magnetometer}}$}
\end{bytefield}

Dieser Modus wird auch aktiv, wenn kein gültiger Modusbefehl erkannt wurde.

\subsubsection{Roll-Pitch-Yaw (Modus 42)}

In diesem Modus (Prefix \emph{42\textsubscript{dec}}) werden die aus der \gls{dcm} extrahierten \textsc{Euler}'schen Winkel (Tait-Bryan $X\text{--}Y\text{--}Z$) übertragen (vgl. Abschnitt~\ref{subsec:herleitung_winkel_dcm}).
Die Winkel liegen im \gls{q16}-Format vor, der zur Extraktion verwendete Code ist in Listing~\ref{lst:libfixmath_dcm_euler} dargestellt.

\begin{bytefield}[bitwidth=1.2em]{13}
	\bitheader{0-12} \\
	\colorbitbox{lightgreen}{1}{42} & 
	\bitbox{4}{Roll $\theta$} & \bitbox{4}{Pitch $\phi$} & \bitbox{4}{Yaw $\psi$}
\end{bytefield}

\subsubsection{Orientierungs-Quaternion (Modus 43)}

In diesem Modus (Prefix \emph{43\textsubscript{dec}}) wird zur effizienten Übertragung der singularitätsfreien Orientierung anstelle der vollständigen \gls{dcm} ein
Orientierungs-Quaternion übertragen, wobei die Komponenten im \gls{q16}-Format vorliegen.

\begin{bytefield}[bitwidth=1.2em]{17}
	\bitheader{0-16} \\
	\colorbitbox{lightgreen}{1}{43} & 
	\bitbox{4}{W} & \bitbox{4}{X} & \bitbox{4}{Y} & \bitbox{4}{Z}
\end{bytefield}

Der zur Generierung des Quaternions verwendete Code kann in Listing~\ref{lst:quaternion_from_kalman} gefunden werden.

\subsubsection{Orientierungs-Quaternion und Roll-Pitch-Yaw (Modus 44)}

Dieser Modus (Prefix \emph{44\textsubscript{dec}}) ist eine Kombination aus den Modi 42 und 43 und kann verwendet werden, um die eigenständige Berechnung der \textsc{Euler}'schen Winkel
auf dem Hostrechner zu ersparen.

\begin{bytefield}[bitwidth=1.2em]{29}
	\bitheader{0-28} \\
	\colorbitbox{lightgreen}{1}{44} & 
	\bitbox{4}{W} & \bitbox{4}{X} & \bitbox{4}{Y} & \bitbox{4}{Z} &
	\bitbox{4}{Roll $\theta$} & \bitbox{4}{Pitch $\phi$} & \bitbox{4}{Yaw $\psi$}
\end{bytefield}

\subsection{Übertragungsprotokoll}

\subsubsection{Übertragung Host zu Firmware}
\label{subsubsec:transmission_host_to_client}

Da die Firmware keine komplexen Befehle, sondern lediglich Moduswechsel kennt, bestehen Kommandos vom Host aus lediglich einem Byte, welches dem zu aktivierenden Modus entspricht. 
Diese Modi sind in Abschnitt~\ref{subsec:streamingmodi} (ab Seite~\pageref{subsec:streamingmodi}) definiert. Der vom Host zu sendende Wert entspricht dabei dem jeweiligen Prefix.

\subsubsection{Übertragung Firmware zu Host}

Hinsichtlich der seriellen Übertragung von der Firmware an den Hostrechner per \gls{uart} wurde ein Kommunikationsprotokoll (genannt \gls{p2pp}) entworfen,
um die Nachsynchronisierbarkeit der Daten zu gewährleisten.

Den eigentlichen Daten vorgeschaltet ist eine frei definierbare Präambel. In der umgesetzten Implementierung besteht diese aus den Bytes 
\texttt{218}, \texttt{122} (\texttt{0xDA7A}, Hexspeak für "`DATA"'). Die Präambel wird vom Dekoder selbst ignoriert, kann jedoch verwendet werden, 
um Zeilenumbrüche oder Markierungen in einem Terminalprogramm zu erzwingen.

\begin{bytefield}[bitwidth=4em]{2}

	\bitheader{0-1} \\
	
	\begin{rightwordgroup}{Präambel}
		\bitbox{1}{\texttt{0xDA}} & \bitbox{1}{\texttt{0x7A}}
	\end{rightwordgroup} 
	
\end{bytefield}

Das Übertragungsprotokoll ist definiert durch drei Oktette: Den Startmarker \emph{S} = \texttt{0x01} (\gls{soh}), 
der Länge der Nutzdaten \emph{L}, sowie dem Endmarker \emph{E} = \texttt{0x04} (\gls{eot}).

Das eigentliche Datenpaket kann dabei variabler Länge (bis einschließlich 255 Byte) sein, wobei den Daten ein
benutzerdefiniertes Prefix \emph{P} vorgeschaltet sein kann, um das Codieren von Pakettypen zu erleichtern.
Da die Länge des Prefixes mit im Längenfeld \emph{L} kodiert ist --- es handelt sich nur um eine logische
Trennung, die nicht protokollspezifisch ist --- reduziert sich die maximale (virtuelle) Anzahl der Daten"-ok"-tette entsprechend.
Einen Verwendungszweck der benutzerdefinierten Prefixe stellen die in Abschnitt~\ref{subsec:streamingmodi} definierten 8 bit 
breiten Moduscodes dar.

\begin{bytefield}[bitwidth=1.1em]{32}

	\bitheader{0-31} \\
	
	%\begin{rightwordgroup}{Header}
		\colorbitbox{lightcyan}{1}{S} & \colorbitbox{lightcyan}{1}{L} & \bitbox{1}{P} &	\bitbox[rt]{29}{} \\
	% \end{rightwordgroup} \\
	
	\wordbox[lr]{1}{Nutzdaten} \\
	\skippedwords \\
	\wordbox[lr]{1}{} \\
	\bitbox[lrb]{31}{} & \colorbitbox{lightcyan}{1}{E}

\end{bytefield}

Die entsprechende Sendefunktion im \gls{p2pp}-Encoder ist wie folgt implementiert:

\begin{lstlisting}[style=lolc]
void P2PPE_TransmissionPrefixed(
	register const uint8_t*const prefix, 
	register uint8_t prefixCount, 
	register const uint8_t*const data, 
	register uint8_t dataCount, 
	register void (*sendHandler)(uint8_t dataByte))
{
	/* send the preamble */
	for (int i=0; i<DEFAULT_PREAMBLE_LENGTH; ++i)
	{
		sendHandler(default_preamble[i]); /* 0xDA, 0x7A */
	}
	
	/* send the header */
	sendHandler(SOH);
	sendHandler(dataCount + prefixCount);
	
	/* send prefix */
	for (int i=0; i<prefixCount; ++i)
	{
		register uint8_t byte = prefix[i];
		encodeAndSend(byte, sendHandler);
	}
	
	/* send data */
	for (int i=0; i<dataCount; ++i)
	{
		register uint8_t byte = data[i];	
		encodeAndSend(byte, sendHandler);
	}
	
	/* send data frame end */
	sendHandler(EOT);
}
\end{lstlisting}

Da das Paketende durch den \gls{eot}-Marker gesetzt ist, darf dieser Wert (sowie das Zeichen \gls{esc}) in den
Nutzdaten nicht vorkommen. Tritt ein solcher Wert auf, wird das wird \gls{esc} (\texttt{0x1B}) eingefügt
und der ursprüngliche Inhalt mit dem Wert \texttt{0x42} ver\textsc{xor}t übertragen.

\begin{lstlisting}[style=lolc]
static inline void encodeAndSend(register uint8_t byte, register void (*sendHandler)(uint8_t dataByte))
{
	if ( EOT == byte || ESC == byte)
	{
		sendHandler(ESC);
		byte ^= ESC_XOR; /* ESC_XOR = 0x42 */
	}
	
	sendHandler(byte);	
}
\end{lstlisting}

\subsection{P2PP-Decoder}
\label{subsec:p2pp_decoder}

Decoder für das \gls{p2pp}-Protokoll wurden sowohl in MATLAB, als auch in C\# geschrieben. Beispielimplementierungen in MATLAB können in den
Listings~\ref{lst:matlab-p2ppdecoder-setup} und \ref{lst:matlab-p2ppdecoder} gefunden werden, eine Implementierung für C\# findet sich in Listing~\ref{lst:csharp-p2ppdecoder}.

Als wesentlich für den performanten Empfang von Daten über die serielle Schnittstelle in MATLAB stellten sich zwei Dinge heraus: Der Dekoder darf\footnote{Bis einschließlich MATLAB R2013b}
nicht als Klasse implementiert sein. Dies bringt extreme Performanceeinbußen mit sich bringt, was der internen Handhabung von Klassen in MATLAB geschuldet ist.

Zum anderen sollte die (üblicherweise empfohlene) Verwendung des \texttt{serial}-Objektes zum Lesen mittels \texttt{fread} vermieden werden, da diese Funktion für
Parameter jenes Typs inperformant implementiert ist\footnote{Dies kann in MATLAB eingesehen werden.}. Um die (oft überflüssige, aber aufwendige) Konstruktion von Fehlerstrings und wiederkehrende
Java-Calls zum Beziehen des Sockets zu vermeiden, schlagen wir den in Listing~\ref{lst:matlab-serial-conf} und \ref{lst:matlab-serial-grab} dargestellten Nutzungsweg vor.

Zuerst wird das Serial-Objekt wie üblich mittels \texttt{serial(...)} bezogen. In Listing~\ref{lst:matlab-serial-conf} wird exemplarisch der Port \texttt{COM3} mit 115,2 kbaud und 
der üblichen Einstellung "`8-N-1"' verwendet. Ein Interner Puffer von 1024 Byte wird eingerichtet und der Lesemodus auf \emph{continuous} geschaltet, um unnötiges Polling (Modus \emph{manual}) zu vermeiden.
Anschließend wird der Socket geöffnet.

\begin{lstlisting}[style=lolmatlab,caption={Konfiguration des Serial-Ports in MATLAB},label=lst:matlab-serial-conf]
s = serial('COM3', ...
        'FlowControl', 'none', ...
        'BaudRate', 115200, ...
        'DataBits', 8, ...
        'Parity', 'none', ...
        'StopBits', 1, ...
        'TimeOut', 1, ...
        'InputBufferSize', 1024, ...
        'ReadAsyncMode', 'continuous', ...
        'Terminator', 0, ...
        'BytesAvailableFcnCount', 12, ...
        'BytesAvailableFcnMode', 'byte' ...
        );

fopen(s);
\end{lstlisting}

Anstelle nun direkt mittels \texttt{fread(s)} Daten anzufordern, wird einmalig mittels \texttt{igetfield} eine Referenz auf das native Java-Objekt bezogen. Dieses
kann dann mittels einer überladenen Version von \texttt{fread} ausgewertet werden (vgl. Listing~\ref{lst:matlab-serial-grab}).

\begin{lstlisting}[style=lolmatlab,caption={Verwendung des Serial-Ports in MATLAB},label=lst:matlab-serial-grab]
% zu Beginn der Funktion, nach fopen(s)
sjobject = igetfield(s, 'jobject');

% in der Empfangsschleife
bulkSize = 80; % max. 80 Byte pro Lesevorgang
rawout = fread(sjobject, bulkSize, 0, 0); % ..., 0, 0 steht fuer "unsigned integer, 8 bit"
bytes = typecast(rawout(1), 'uint8');     % dies hat jedoch keinerlei Einfluss, daher manueller cast

% schliessen wie ueblich
fclose(s);
delete(s);
\end{lstlisting}
