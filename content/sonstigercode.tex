\chapter{Ablauf und Kommunikation}

\section{Ablauf der Verarbeitung}

Die Realisierung der Firmware kann als Zustandsapparat verstanden werden, wie er Abbildung~\ref{fig:processing_states} entnommen werden kann.

\begin{figure}[htbp]
	\begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto] 
		 \node[state,initial] (q_0)   {init}; 
		 \node[state] (q_1) [right=of q_0] {idle}; 
		 \node[state](q_3) [above=of q_1] {MPU6050};
		 \node[state](q_4) [right=of q_1] {HMC5883L};
		 \node[state] (q_2) [above=of q_4] {register};
		 \node[state,accepting] (q_6) [below=of q_1] {correct};
		 \node[state,accepting] (q_5) [right=of q_6] {predict};
		 \node[state,accepting] (q_7) [left=of q_6] {output};
			\path[->] 
			(q_0) edge  node {} (q_1)
			(q_1) edge  node  {IRQ} (q_3)
						edge  node  {timer} (q_4)
						edge  node  {registered} (q_5)
						edge [bend left] node {data} (q_7)
			(q_3) edge  node {} (q_2) 
			(q_4) edge  node {} (q_2)
			(q_2) edge  node {} (q_1)
			(q_5) edge  node {} (q_6)
			(q_6) edge  node {} (q_1)
			(q_7) edge [bend left] node {} (q_1);
	\end{tikzpicture}
	\caption[Zustandsdiagramm der Datenverarbeitung]{Zustandsdiagramm der Datenverarbeitung}
	\label{fig:processing_states}
\end{figure}

Der \emph{idle}-Zustand ist dabei nicht notwendigerweise "`im Stillstand"': Da in den in den frühen Entwicklungsphasen --- nicht zuletzt wegen des in Abschnitt~\ref{subsec:mpu6050_lessonslearned} 
beschriebenen Interruptproblems --- die Verwendung des \gls{wfi}-Befehls zum Betreten des Energiesparmodus zu Problemen führte, wurde ein reiner 
Polling-Betrieb umgesetzt und auf die Verwendung der Energiespar- und Synchronisationsmechanismen \gls{wfi}, sowie \gls{wev}/\gls{sev} (mit Ausnahme der Realisierung des 
UART-Treibers zur Synchronisation auf dem Ausgabepuffer.) verzichtet.

Wie in Abschnitt~\ref{sec:mpu6050} beschrieben, signalisiert eine Veränderung auf der Data Ready-Leitung der MPU6050 das Vorliegen neuer Daten, woraufhin
diese von der Hauptverarbeitungsschleife über den \gls{i2c}-Bus abgerufen werden. Analog (Abschnitt~\ref{sec:hmc5883l}) signalisiert der Ablauf einer definierten Zeit über den
\gls{systick}-Timer das Vorhandensein neuer Daten auf dem HMC5883L.

Liegen Daten eines dieser Sensoren vor, werden diese am Fusionstreiber registriert und anschließend weiterverarbeitet. Dies ist in Abschnitt~\ref{sec:impl_fusion} beschrieben.
Anschließend an die Fusion werden die Daten zur Übertragung an den Host gesendet, wobei das in Abschnitt~\ref{sec:serial_transmission} beschriebene Protokoll zum Tragen kommt.
Die serielle Übertragung wurde dabei Interruptgetrieben umgesetzt, so dass sie weitgehend asynchron zur restlichen Datenverarbeitung läuft (vgl. dazu Abbildung~\ref{fig:logan-detail}).

Das System wurde auf einem Breadboard implementiert, wie es in Abbildung~\ref{fig:prototype} dargestellt ist. Technisch fragwürdig, aber hilfreich: Als nützlich stellten sich 
Gummibänder zum Fixieren des FRDM-KL25Z, sowie lange USB-Kabel heraus, da auf diese Weise die korrekte Funktionsweise der Fusion einfach und einhändig überprüft werden konnte.
Ein Bild des Systems in Betrieb und der Anzeige der Orientierung mittels OpenGL kann in Abbildung~\ref{fig:fused-csharp} gefunden werden. Auf den Code zur Darstellung wird jedoch im Folgenden
nicht weiter eingegangen.

\begin{figure}[htbp]
		\centering
	\begin{subfigure}[b]{\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{./images/board.jpg}
		\caption[FRDM-KL25Z mit externen Sensoren]{FRDM-KL25Z mit externen Sensoren: MPU6050 (blau) und HMC5883L (rot)}
		\label{fig:board}
	\end{subfigure}

	\begin{subfigure}[b]{\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{./images/board-mit-logan.jpg}
		\caption[FRDM-KL25Z mit angeschlossenem Logic-Analyzer]{FRDM-KL25Z mit angeschlossenem Logic-Analyzer (rechts). Im Hintergrund links der verwendete UART-zu-USB-Transceiver.}
		\label{fig:board-logan}
	\end{subfigure}
	
	\caption{Prototyp auf dem Breadboard}
	\label{fig:prototype}
\end{figure}


\section{Serielle Übertragung}
\label{sec:serial_transmission}

\subsection{Streamingmodi}
\label{subsec:streamingmodi}

Die Firmware ist in der Lage, Sensor- und Fusionsdaten in verschiedenen Modi über die serielle Schnittstelle auszugeben. Zur Aktivierung dieser Modi siehe Abschnitt~\ref{subsubsec:transmission_host_to_client}.

\subsubsection{Sensorrohdaten (Modus 0)}

Im Rohdatenmodus (Prefix \emph{0\textsubscript{dec}}) werden die ungefilterten Sensordaten des MPU6050-Accelerometers, sowie des HMC5883L-Magnetometers übertragen. Zur Unterstützung der Verarbeitung
und um Unabhängigkeit von der Konfiguration zu erreichen, werden die Daten konvertiert in das \gls{q16}-Format übertragen.

\begin{bytefield}[bitwidth=1.2em]{25}
	\bitheader{0-24} \\
	\colorbitbox{lightgreen}{1}{0} & 
	\bitbox{4}{A\textsubscript{x}} & \bitbox{4}{A\textsubscript{y}} & \bitbox{4}{A\textsubscript{z}} &
	\bitbox{4}{M\textsubscript{x}} & \bitbox{4}{M\textsubscript{y}} & \bitbox{4}{M\textsubscript{z}}% \\
	%\bitbox[t]{1}{} & \bitbox[t]{6}{$\underbrace{\hspace{6.6em}}_{\text{\normalsize Accelerometer}}$} & \bitbox[t]{6}{$\underbrace{\hspace{6.6em}}_{\text{\normalsize Magnetometer}}$}
\end{bytefield}

Dieser Modus wird auch aktiv, wenn kein gültiger Modusbefehl erkannt wurde.

\subsubsection{Roll-Pitch-Yaw (Modus 42)}

In diesem Modus (Prefix \emph{42\textsubscript{dec}}) werden die aus der \gls{dcm} extrahierten \textsc{Euler}'schen Winkel (Tait-Bryan $X\text{--}Y\text{--}Z$) übertragen (vgl. Abschnitt~\ref{subsec:herleitung_winkel_dcm}).
Die Winkel liegen im \gls{q16}-Format vor, der zur Extraktion verwendete Code ist in Listing~\ref{lst:libfixmath_dcm_euler} dargestellt.

\begin{bytefield}[bitwidth=1.2em]{13}
	\bitheader{0-12} \\
	\colorbitbox{lightgreen}{1}{42} & 
	\bitbox{4}{Roll $\theta$} & \bitbox{4}{Pitch $\phi$} & \bitbox{4}{Yaw $\psi$}
\end{bytefield}

\subsubsection{Orientierungs-Quaternion (Modus 43)}

In diesem Modus (Prefix \emph{43\textsubscript{dec}}) wird zur effizienten Übertragung der singularitätsfreien Orientierung anstelle der vollständigen \gls{dcm} ein
Orientierungs-Quaternion übertragen, wobei die Komponenten im \gls{q16}-Format vorliegen.

\begin{bytefield}[bitwidth=1.2em]{17}
	\bitheader{0-16} \\
	\colorbitbox{lightgreen}{1}{43} & 
	\bitbox{4}{W} & \bitbox{4}{X} & \bitbox{4}{Y} & \bitbox{4}{Z}
\end{bytefield}

Der zur Generierung des Quaternions verwendete Code kann in Listing~\ref{lst:quaternion_from_kalman} gefunden werden.

\subsubsection{Orientierungs-Quaternion und Roll-Pitch-Yaw (Modus 44)}
\label{subsubsec:quat-and-rpy}

Dieser Modus (Prefix \emph{44\textsubscript{dec}}) ist eine Kombination aus den Modi 42 und 43 und kann verwendet werden, um die eigenständige Berechnung der \textsc{Euler}'schen Winkel
auf dem Hostrechner zu ersparen.

\begin{bytefield}[bitwidth=1.2em]{29}
	\bitheader{0-28} \\
	\colorbitbox{lightgreen}{1}{44} & 
	\bitbox{4}{W} & \bitbox{4}{X} & \bitbox{4}{Y} & \bitbox{4}{Z} &
	\bitbox{4}{Roll $\theta$} & \bitbox{4}{Pitch $\phi$} & \bitbox{4}{Yaw $\psi$}
\end{bytefield}

\subsection{Übertragungsprotokoll}

\subsubsection{Übertragung Host zu Firmware}
\label{subsubsec:transmission_host_to_client}

Da die Firmware keine komplexen Befehle, sondern lediglich Moduswechsel kennt, bestehen Kommandos vom Host aus lediglich einem Byte, welches dem zu aktivierenden Modus entspricht. 
Diese Modi sind in Abschnitt~\ref{subsec:streamingmodi} (ab Seite~\pageref{subsec:streamingmodi}) definiert. Der vom Host zu sendende Wert entspricht dabei dem jeweiligen Prefix.

\subsubsection{Übertragung Firmware zu Host}
\label{subsubsec:firware_to_host}

Hinsichtlich der seriellen Übertragung von der Firmware an den Hostrechner per \gls{uart} wurde ein Kommunikationsprotokoll (genannt \gls{p2pp}) entworfen,
um die Nachsynchronisierbarkeit der Daten zu gewährleisten.

Den eigentlichen Daten vorgeschaltet ist eine frei definierbare Präambel. In der umgesetzten Implementierung besteht diese aus den Bytes 
\texttt{218}, \texttt{122} (\texttt{0xDA7A}, Hexspeak für "`DATA"'). Die Präambel wird vom Dekoder selbst ignoriert, kann jedoch verwendet werden, 
um Zeilenumbrüche oder Markierungen in einem Terminalprogramm zu erzwingen.

\begin{bytefield}[bitwidth=4em]{2}

	\bitheader{0-1} \\
	
	\begin{rightwordgroup}{Präambel}
		\bitbox{1}{\texttt{0xDA}} & \bitbox{1}{\texttt{0x7A}}
	\end{rightwordgroup} 
	
\end{bytefield}

Das Übertragungsprotokoll ist definiert durch drei Oktette: Den Startmarker \emph{S} = \texttt{0x01} (\gls{soh}), 
der Länge der Nutzdaten \emph{L}, sowie dem Endmarker \emph{E} = \texttt{0x04} (\gls{eot}).

Das eigentliche Datenpaket kann dabei variabler Länge (bis einschließlich 255 Byte) sein, wobei den Daten ein
benutzerdefiniertes Prefix \emph{P} vorgeschaltet sein kann, um das Codieren von Pakettypen zu erleichtern.
Da die Länge des Prefixes mit im Längenfeld \emph{L} kodiert ist --- es handelt sich nur um eine logische
Trennung, die nicht protokollspezifisch ist --- reduziert sich die maximale (virtuelle) Anzahl der Daten"-ok"-tette entsprechend.
Einen Verwendungszweck der benutzerdefinierten Prefixe stellen die in Abschnitt~\ref{subsec:streamingmodi} definierten 8 bit 
breiten Moduscodes dar.

\begin{bytefield}[bitwidth=1.1em]{32}

	\bitheader{0-31} \\
	
	%\begin{rightwordgroup}{Header}
		\colorbitbox{lightcyan}{1}{S} & \colorbitbox{lightcyan}{1}{L} & \bitbox{1}{P} &	\bitbox[rt]{29}{} \\
	% \end{rightwordgroup} \\
	
	\wordbox[lr]{1}{Nutzdaten} \\
	\skippedwords \\
	\wordbox[lr]{1}{} \\
	\bitbox[lrb]{31}{} & \colorbitbox{lightcyan}{1}{E}

\end{bytefield}

Die entsprechende Sendefunktion im \gls{p2pp}-Encoder ist wie folgt implementiert:

\begin{lstlisting}[style=lolc]
void P2PPE_TransmissionPrefixed(
	register const uint8_t*const prefix, 
	register uint8_t prefixCount, 
	register const uint8_t*const data, 
	register uint8_t dataCount, 
	register void (*sendHandler)(uint8_t dataByte))
{
	/* send the preamble */
	for (int i=0; i<DEFAULT_PREAMBLE_LENGTH; ++i)
	{
		sendHandler(default_preamble[i]); /* 0xDA, 0x7A */
	}
	
	/* send the header */
	sendHandler(SOH);
	sendHandler(dataCount + prefixCount);
	
	/* send prefix */
	for (int i=0; i<prefixCount; ++i)
	{
		register uint8_t byte = prefix[i];
		encodeAndSend(byte, sendHandler);
	}
	
	/* send data */
	for (int i=0; i<dataCount; ++i)
	{
		register uint8_t byte = data[i];	
		encodeAndSend(byte, sendHandler);
	}
	
	/* send data frame end */
	sendHandler(EOT);
}
\end{lstlisting}

Da das Paketende durch den \gls{eot}-Marker gesetzt ist, darf dieser Wert (sowie das Zeichen \gls{esc}) in den
Nutzdaten nicht vorkommen. Tritt ein solcher Wert auf, wird das wird \gls{esc} (\texttt{0x1B}) eingefügt
und der ursprüngliche Inhalt mit dem Wert \texttt{0x42} ver\textsc{xor}t übertragen.

\begin{lstlisting}[style=lolc]
static inline void encodeAndSend(register uint8_t byte, register void (*sendHandler)(uint8_t dataByte))
{
	if ( EOT == byte || ESC == byte)
	{
		sendHandler(ESC);
		byte ^= ESC_XOR; /* ESC_XOR = 0x42 */
	}
	
	sendHandler(byte);	
}
\end{lstlisting}

\subsection{P2PP-Decoder}
\label{subsec:p2pp_decoder}

Decoder für das \gls{p2pp}-Protokoll wurden sowohl in MATLAB, als auch in C\# geschrieben. Beispielimplementierungen in MATLAB können in den
Listings~\ref{lst:matlab-p2ppdecoder-setup} und \ref{lst:matlab-p2ppdecoder} gefunden werden, eine Implementierung für C\# findet sich in Listing~\ref{lst:csharp-p2ppdecoder}.

Als wesentlich für den performanten Empfang von Daten über die serielle Schnittstelle in MATLAB stellten sich zwei Dinge heraus: Der Dekoder darf\footnote{Bis einschließlich MATLAB R2013b}
nicht als Klasse implementiert sein. Dies bringt extreme Performanceeinbußen mit sich bringt, was der internen Handhabung von Klassen in MATLAB geschuldet ist.

Zum anderen sollte die (üblicherweise empfohlene) Verwendung des \texttt{serial}-Objektes zum Lesen mittels \texttt{fread} vermieden werden, da diese Funktion für
Parameter jenes Typs inperformant implementiert ist\footnote{Dies kann in MATLAB eingesehen werden.}. Um die (oft überflüssige, aber aufwendige) Konstruktion von Fehlerstrings und wiederkehrende
Java-Calls zum Beziehen des Sockets zu vermeiden, schlagen wir den in Listing~\ref{lst:matlab-serial-conf} und \ref{lst:matlab-serial-grab} dargestellten Nutzungsweg vor.

Zuerst wird das Serial-Objekt wie üblich mittels \texttt{serial(...)} bezogen. In Listing~\ref{lst:matlab-serial-conf} wird exemplarisch der Port \texttt{COM3} mit 115,2 kbaud und 
der üblichen Einstellung "`8-N-1"' verwendet. Ein Interner Puffer von 1024 Byte wird eingerichtet und der Lesemodus auf \emph{continuous} geschaltet, um unnötiges Polling (Modus \emph{manual}) zu vermeiden.
Anschließend wird der Socket geöffnet.

\begin{lstlisting}[style=lolmatlab,caption={Konfiguration des Serial-Ports in MATLAB},label=lst:matlab-serial-conf]
s = serial('COM3', ...
        'FlowControl', 'none', ...
        'BaudRate', 115200, ...
        'DataBits', 8, ...
        'Parity', 'none', ...
        'StopBits', 1, ...
        'TimeOut', 1, ...
        'InputBufferSize', 1024, ...
        'ReadAsyncMode', 'continuous', ...
        'Terminator', 0, ...
        'BytesAvailableFcnCount', 12, ...
        'BytesAvailableFcnMode', 'byte' ...
        );

fopen(s);
\end{lstlisting}

Anstelle nun direkt mittels \texttt{fread(s)} Daten anzufordern, wird einmalig mittels \texttt{igetfield} eine Referenz auf das native Java-Objekt bezogen. Dieses
kann dann mittels einer überladenen Version von \texttt{fread} ausgewertet werden (vgl. Listing~\ref{lst:matlab-serial-grab}).

\begin{lstlisting}[style=lolmatlab,caption={Verwendung des Serial-Ports in MATLAB},label=lst:matlab-serial-grab]
% zu Beginn der Funktion, nach fopen(s)
sjobject = igetfield(s, 'jobject');

% in der Empfangsschleife
bulkSize = 80; % max. 80 Byte pro Lesevorgang
rawout = fread(sjobject, bulkSize, 0, 0); % ..., 0, 0 steht fuer "unsigned integer, 8 bit"
bytes = typecast(rawout(1), 'uint8');     % dies hat jedoch keinerlei Einfluss, daher manueller cast

% schliessen wie ueblich
fclose(s);
delete(s);
\end{lstlisting}
