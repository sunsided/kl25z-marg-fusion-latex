\chapter{Sonstiger Code}

\section{Serielle Übertragung}

\subsection{Streamingmodi}
\label{subsec:streamingmodi}

Die Firmware ist in der Lage, Sensor- und Fusionsdaten in verschiedenen Modi über die serielle Schnittstelle auszugeben. Zur Aktivierung dieser Modi siehe Abschnitt~\ref{subsubsec:transmission_host_to_client}.

\subsubsection{Sensorrohdaten (Modus 0)}

Im Rohdatenmodus (Prefix \emph{0\textsubscript{dec}}) werden die ungefilterten Sensordaten des MPU6050-Accelerometers, sowie des HMC5883L-Magnetometers übertragen. Zur Unterstützung der Verarbeitung
und um Unabhängigkeit von der Konfiguration zu erreichen, werden die Daten konvertiert in das \gls{q16}-Format übertragen.

\begin{bytefield}[bitwidth=1.2em]{25}
	\bitheader{0-24} \\
	\colorbitbox{lightgreen}{1}{0} & 
	\bitbox{4}{A\textsubscript{x}} & \bitbox{4}{A\textsubscript{y}} & \bitbox{4}{A\textsubscript{z}} &
	\bitbox{4}{M\textsubscript{x}} & \bitbox{4}{M\textsubscript{y}} & \bitbox{4}{M\textsubscript{z}}% \\
	%\bitbox[t]{1}{} & \bitbox[t]{6}{$\underbrace{\hspace{6.6em}}_{\text{\normalsize Accelerometer}}$} & \bitbox[t]{6}{$\underbrace{\hspace{6.6em}}_{\text{\normalsize Magnetometer}}$}
\end{bytefield}

Dieser Modus wird auch aktiv, wenn kein gültiger Modusbefehl erkannt wurde.

\subsubsection{Roll-Pitch-Yaw (Modus 42)}

In diesem Modus (Prefix \emph{42\textsubscript{dec}}) werden die aus der \gls{dcm} extrahierten \textsc{Euler}'schen Winkel\todo{howto - Verweis auf Fusion!} (Tait-Bryan $X\text{--}Y\text{--}Z$) übertragen.
Die Winkel liegen im \gls{q16}-Format vor.

\begin{bytefield}[bitwidth=1.2em]{13}
	\bitheader{0-12} \\
	\colorbitbox{lightgreen}{1}{42} & 
	\bitbox{4}{Roll $\theta$} & \bitbox{4}{Pitch $\phi$} & \bitbox{4}{Yaw $\psi$}
\end{bytefield}

\subsubsection{Orientierungs-Quaternion (Modus 43)}

In diesem Modus (Prefix \emph{43\textsubscript{dec}}) wird zur effizienten Übertragung der singularitätsfreien Orientierung anstelle der vollständigen \gls{dcm} ein
Orientierungs-Quaternion übertragen\todo{howto - Verweis auf Fusion!}, wobei die Komponenten im \gls{q16}-Format vorliegen.

\begin{bytefield}[bitwidth=1.2em]{17}
	\bitheader{0-16} \\
	\colorbitbox{lightgreen}{1}{43} & 
	\bitbox{4}{W} & \bitbox{4}{X} & \bitbox{4}{Y} & \bitbox{4}{Z}
\end{bytefield}

\subsubsection{Orientierungs-Quaternion und Roll-Pitch-Yaw (Modus 44)}

Dieser Modus (Prefix \emph{44\textsubscript{dec}}) ist eine Kombination aus den Modi 42 und 43 und kann verwendet werden, um die eigenständige Berechnung der \textsc{Euler}'schen Winkel
auf dem Hostrechner zu ersparen.

\begin{bytefield}[bitwidth=1.2em]{29}
	\bitheader{0-28} \\
	\colorbitbox{lightgreen}{1}{44} & 
	\bitbox{4}{W} & \bitbox{4}{X} & \bitbox{4}{Y} & \bitbox{4}{Z} &
	\bitbox{4}{Roll $\theta$} & \bitbox{4}{Pitch $\phi$} & \bitbox{4}{Yaw $\psi$}
\end{bytefield}

\subsection{Übertragungsprotokoll}

\subsubsection{Übertragung Host zu Firmware}
\label{subsubsec:transmission_host_to_client}

Da die Firmware keine komplexen Befehle, sondern lediglich Moduswechsel kennt, bestehen Kommandos vom Host aus lediglich einem Byte, welches dem zu aktivierenden Modus entspricht. 
Diese Modi sind in Abschnitt~\ref{subsec:streamingmodi} (ab Seite~\pageref{subsec:streamingmodi}) definiert. Der vom Host zu sendende Wert entspricht dabei dem jeweiligen Prefix.

\subsubsection{Übertragung Firmware zu Host}

Hinsichtlich der seriellen Übertragung von der Firmware an den Hostrechner per \gls{uart} wurde ein Kommunikationsprotokoll (genannt \gls{p2pp}) entworfen,
um die Nachsynchronisierbarkeit der Daten zu gewährleisten.

Den eigentlichen Daten vorgeschaltet ist eine frei definierbare Präambel. In der umgesetzten Implementierung besteht diese aus den Bytes 
\texttt{218}, \texttt{122} (\texttt{0xDA7A}, Hexspeak für "`DATA"'). Die Präambel wird vom Dekoder selbst ignoriert, kann jedoch verwendet werden, 
um Zeilenumbrüche oder Markierungen in einem Terminalprogramm zu erzwingen.

\begin{bytefield}[bitwidth=4em]{2}

	\bitheader{0-1} \\
	
	\begin{rightwordgroup}{Präambel}
		\bitbox{1}{\texttt{0xDA}} & \bitbox{1}{\texttt{0x7A}}
	\end{rightwordgroup} 
	
\end{bytefield}

Das Übertragungsprotokoll ist definiert durch drei Oktette: Den Startmarker \emph{S} = \texttt{0x01} (\gls{soh}), 
der Länge der Nutzdaten \emph{L}, sowie dem Endmarker \emph{E} = \texttt{0x04} (\gls{eot}).

Das eigentliche Datenpaket kann dabei variabler Länge (bis einschließlich 255 Byte) sein, wobei den Daten ein
benutzerdefiniertes Prefix \emph{P} vorgeschaltet sein kann, um das Codieren von Pakettypen zu erleichtern.
Da die Länge des Prefixes mit im Längenfeld \emph{L} kodiert ist --- es handelt sich nur um eine logische
Trennung, die nicht protokollspezifisch ist --- reduziert sich die maximale (virtuelle) Anzahl der Daten"-ok"-tette entsprechend.
Einen Verwendungszweck der benutzerdefinierten Prefixe stellen die in Abschnitt~\ref{subsec:streamingmodi} definierten 8 bit 
breiten Moduscodes dar.

\begin{bytefield}[bitwidth=1.1em]{32}

	\bitheader{0-31} \\
	
	%\begin{rightwordgroup}{Header}
		\colorbitbox{lightcyan}{1}{S} & \colorbitbox{lightcyan}{1}{L} & \bitbox{1}{P} &	\bitbox[rt]{29}{} \\
	% \end{rightwordgroup} \\
	
	\wordbox[lr]{1}{Nutzdaten} \\
	\skippedwords \\
	\wordbox[lr]{1}{} \\
	\bitbox[lrb]{31}{} & \colorbitbox{lightcyan}{1}{E}

\end{bytefield}

Die entsprechende Sendefunktion im \gls{p2pp}-Encoder ist wie folgt implementiert:

\begin{lstlisting}[style=lolc]
void P2PPE_TransmissionPrefixed(
	register const uint8_t*const prefix, 
	register uint8_t prefixCount, 
	register const uint8_t*const data, 
	register uint8_t dataCount, 
	register void (*sendHandler)(uint8_t dataByte))
{
	/* send the preamble */
	for (int i=0; i<DEFAULT_PREAMBLE_LENGTH; ++i)
	{
		sendHandler(default_preamble[i]); /* 0xDA, 0x7A */
	}
	
	/* send the header */
	sendHandler(SOH);
	sendHandler(dataCount + prefixCount);
	
	/* send prefix */
	for (int i=0; i<prefixCount; ++i)
	{
		register uint8_t byte = prefix[i];
		encodeAndSend(byte, sendHandler);
	}
	
	/* send data */
	for (int i=0; i<dataCount; ++i)
	{
		register uint8_t byte = data[i];	
		encodeAndSend(byte, sendHandler);
	}
	
	/* send data frame end */
	sendHandler(EOT);
}
\end{lstlisting}

Da das Paketende durch den \gls{eot}-Marker gesetzt ist, darf dieser Wert (sowie das Zeichen \gls{esc}) in den
Nutzdaten nicht vorkommen. Tritt ein solcher Wert auf, wird das wird \gls{esc} (\texttt{0x1B}) eingefügt
und der ursprüngliche Inhalt mit dem Wert \texttt{0x42} ver\textsc{xor}t übertragen.

\begin{lstlisting}[style=lolc]
static inline void encodeAndSend(register uint8_t byte, register void (*sendHandler)(uint8_t dataByte))
{
	if ( EOT == byte || ESC == byte)
	{
		sendHandler(ESC);
		byte ^= ESC_XOR; /* ESC_XOR = 0x42 */
	}
	
	sendHandler(byte);	
}
\end{lstlisting}

\subsection{P2PP-Decoder}
\label{subsec:p2pp_decoder}

Decoder für das \gls{p2pp}-Protokoll wurden sowohl in MATLAB, als auch in C\# geschrieben. Beispielimplementierungen in MATLAB können in 
Listings~\ref{lst:matlab-p2ppdecoder-setup} und \ref{lst:matlab-p2ppdecoder} gefunden werden, eine Implementierung für C\# findet sich in Listing~\ref{lst:csharp-p2ppdecoder}.

Als wesentlich für den performanten Empfang von Daten über die serielle Schnittstelle in MATLAB stellten sich zwei Dinge heraus: Der Dekoder darf\footnote{Bis einschließlich MATLAB R2013b}
nicht als Klasse implementiert sein. Dies bringt extreme Performanceeinbußen mit sich bringt, was der internen Handhabung von Klassen in MATLAB geschuldet ist.

Zum anderen sollte die (üblicherweise empfohlene) Verwendung des \texttt{serial}-Objektes zum Lesen mittels \texttt{fread} vermieden werden, da diese Funktion für
Parameter jenes Typs inperformant implementiert ist\footnote{Dies kann in MATLAB eingesehen werden.}. Um die (oft überflüssige, aber aufwendige) Konstruktion von Fehlerstrings und wiederkehrende
Java-Calls zum Beziehen des Sockets zu vermeiden, schlagen wir den in Listing~\ref{lst:matlab-serial-conf} und \ref{lst:matlab-serial-grab} dargestellten Nutzungsweg vor.

Zuerst wird das Serial-Objekt wie gehabt mittels \texttt{serial(...)} bezogen. In Listing~\ref{lst:matlab-serial-conf} wird exemplarisch der Port \texttt{COM3} mit 115,2 kbaud und 
der üblichen Einstellung "`8-N-1"' verwendet. Ein Interner Puffer von 1024 Byte wird eingerichtet und der Lesemodus auf \emph{continuous} geschaltet, um unnötiges Polling (Modus \emph{manual}) zu vermeiden.
Anschließend wird der Socket geöffnet.

\begin{lstlisting}[style=lolmatlab,caption={Konfiguration des Serial-Ports in MATLAB},label=lst:matlab-serial-conf]
s = serial('COM3', ...
        'FlowControl', 'none', ...
        'BaudRate', 115200, ...
        'DataBits', 8, ...
        'Parity', 'none', ...
        'StopBits', 1, ...
        'TimeOut', 1, ...
        'InputBufferSize', 1024, ...
        'ReadAsyncMode', 'continuous', ...
        'Terminator', 0, ...
        'BytesAvailableFcnCount', 12, ...
        'BytesAvailableFcnMode', 'byte' ...
        );

fopen(s);
\end{lstlisting}

Anstelle nun direkt mittels \texttt{fread(s)} Daten anzufordern, wird einmalig mittels \texttt{igetfield} eine Referenz auf das native Java-Objekt bezogen. Dieses
kann dann mittels einer überladenen Version von \texttt{fread} ausgewertet werden (vgl. Listing~\ref{lst:matlab-serial-grab}).

\begin{lstlisting}[style=lolmatlab,caption={Verwendung des Serial-Ports in MATLAB},label=lst:matlab-serial-grab]
% zu Beginn der Funktion, nach fopen(s)
sjobject = igetfield(s, 'jobject');

% in der Empfangsschleife
bulkSize = 80; % max. 80 Byte pro Lesevorgang
rawout = fread(sjobject, bulkSize, 0, 0); % ..., 0, 0 steht fuer "unsigned integer, 8 bit"
bytes = typecast(rawout(1), 'uint8');     % dies hat jedoch keinerlei Einfluss, daher manueller cast

% schliessen wie ueblich
fclose(s);
delete(s);
\end{lstlisting}

\begin{lstlisting}[style=lolmatlab,caption={Setup des \gls{p2pp}-Decoders in MATLAB},label=lst:matlab-p2ppdecoder-setup]
function prepareProtocolDecode
        
    % Definitions
    global SOH EOT ESC ESC_XOR DA TA
    SOH     = uint8(1);
    EOT     = uint8(4);
    ESC     = uint8(27);
    ESC_XOR = uint8(66);
    DA      = uint8(218);
    TA      = uint8(122);

    global state
    state = 0;
    
    % Decoding variables
    global dataLength data dataBytesRead escapeDetected dataReady lastByte
    lastByte = NaN;
    dataLength = 0;
    data = [];
    dataBytesRead = 0;
    escapeDetected = false;
    dataReady = false;
    
    % Data counters
    global sensorDataCount RPY
    RPY = 1;
    sensorDataCount = zeros(3,1);
end
\end{lstlisting}

\begin{lstlisting}[style=lolmatlab,caption={\gls{p2pp}-Decoder in MATLAB},label=lst:matlab-p2ppdecoder]
function [availableData] = protocolDecode(byte)
    global SOH EOT ESC ESC_XOR DA TA
    global state
    global dataLength data dataReady dataBytesRead escapeDetected lastByte

    availableData = 0;
    
    % Switch states
    switch state
        % Await preamble
        case 0
            if byte == DA
                % ignored
            elseif (byte == TA) && (lastByte == DA)
                state = 1; % preamble detected
            else
                % error state
            end

            lastByte = byte;

        % Await SOH
        case 1
            if byte == SOH
                state = 2;
            else
                % error state
            end

        % Read length
        case 2
            dataLength = byte;
            dataBytesRead = 0;
            data = zeros(dataLength, 1, 'uint8');
            state = 3;

        % Read data bytes
        case 3
            if byte == ESC
                escapeDetected = true;
            else
                if escapeDetected
                    byte = bitxor(byte, ESC_XOR);
                    escapeDetected = false;
                end

                dataBytesRead = dataBytesRead + 1;
                data(dataBytesRead) = byte;

                if dataBytesRead == dataLength
                    state = 4;
                end
            end

        % Await EOT
        case 4
            if byte == EOT
                state = 0;
                dataReady = true;
                availableData = dataBytesRead;
            else
                % error state
            end
    end
end
\end{lstlisting}

\begin{lstlisting}[style=lolcsharp,caption={\gls{p2pp}-Decoder in C\#},label=lst:csharp-p2ppdecoder]
class ProtocolDecoder
{
	private const int SOH = 1;
	private const int EOT = 4;
	private const int ESC = 27;
	private const int ESC_XOR = 66;
	private const int DA = 218;
	private const int TA = 122;
	
	private int dataLength = 0;
	private int dataBytesRead = 0;
	private byte[] data;

	private int lastdatum = 0;
	private bool escapeDetected = false;
	private int state = 0;

	public event EventHandler<DataEvent> DataReady;

	/// <summary>
	/// Decodes the specified data btye.
	/// </summary>
	/// <param name="datum">The data byte.</param>
	public void Decode(int datum)
	{
		switch (state)
		{
			case 0: // Await preamble
			{
				if (datum == DA) { /* ignored */ }
				else if ((datum == TA) && (lastdatum == DA))
				{
					// preamble detected
					state = 1;
					break;
				}
				else { /* error case */ }

				// Remember datum for protocol decoding
				lastdatum = datum;
				break;
			}

			case 1: // Await SOH
			{
				if (datum == SOH)
				{
					state = 2; break;
				}
				
				state = 0; // error case
				break;
			}

			case 2: // Read length
			{
				dataLength = datum;
				dataBytesRead = 0;
				data = new byte[dataLength];
				state = 3;
				break;
			}

			case 3: // Read datum
			{
				if (datum == ESC)
				{
					escapeDetected = true;
				}
				else
				{
					// decode escaped byte
					if (escapeDetected)
					{
						datum = datum ^ ESC_XOR;
						escapeDetected = false;
					}

					// store data byte and increment counter
					data[dataBytesRead++] = (byte)datum;

					// if all bytes are read, wait for EOT
					if (dataBytesRead == dataLength)
					{
						state = 4;
					}
				}
				break;
			}
			case 4: // await EOT
			{
				if (datum == EOT)
				{
					state = 0;

					// raise event
					var handler = DataReady;
					if (handler != null)
					{
						handler(this, new DataEvent(data));
					}
					
					break;
				}
				
				state = 0; // error case
				break;
			}
		}
	}
}
\end{lstlisting}