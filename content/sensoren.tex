\section{Sensoren}

Alle in diesem Projekt verwendeten Sensoren verfügen über eine \gls{i2c}-Schnittstelle, über welche die Kommunikation abgewickelt wurde. Einige Module, wie die MPU6050 (siehe Abschnitt~\ref{sec:mpu6050})
verfügen darüberhinaus über Interrupt-Leitungen, welche das Vorliegen neuer Messwerte signalisieren.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{./images/sensors/uncalibrated.png}
	\caption[Sensordaten in Ruhelage]{10-Minuten-Aufnahme der Sensordaten in Ruhelage}
	\label{fig:sensors_unagitated}
\end{figure}


\subsection{MMA8451Q -- Accelerometer}
\label{sec:mma8451q}

Der Freescale MMA8451Q ist der auf dem Freedom-Board verbaute Beschleunigungssensor. Er bietet eine Auflösung von 8 oder 14 Bit (inklusive Vorzeichen) bei einer maximalen 
Samplingrate von 800 Hz (\citealp{mma8451q}) und kann mit bis zu 2.25 MHz Taktung über den \gls{i2c}-Bus 
ausgelesen werden\footnote{Dies entspricht dem sog. "`High Speed Mode \gls{i2c}"', welcher bis 3,4 Mbit/s spezifiziert ist.}.

Zum Test der Interaktion mit dem Sensor wurde ein MATLAB-Skript zur Darstellung des Accelerometer-Vektors und eines virtuellen Horizontes geschrieben.
Eine Ausgabe des Ergebnisses kann in Abbildung~\ref{fig:matlab-video-virthorz} gefunden werden. Der MATLAB-Code zur Darstellung findet sich in Listing~\ref{lst:matlab-virthorz},
die dazu verwendete Funktion zur Berechnung von Roll- und Pitch-Winkeln steht in Listing~\ref{lst:matlab-rollpitch}.

Auf den hierbei verwendeten Übertragungsmechanismus wird in Kapitel~\ref{sec:serial_transmission} auf den Seiten~\pageref{subsubsec:firware_to_host}\,ff und~\pageref{subsec:p2pp_decoder}\,ff näher eingegangen.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{./images/matlab-initial-test-video-virthorz.jpg}
	\caption{Virtueller Horizont mittels MMA8451Q in MATLAB}
	\label{fig:matlab-video-virthorz}
\end{figure}

\subsubsection{Treiber}

Die im Treiber implementierte Registerstruktur des MMA8451Q kann in Listing~\ref{lst:mma8451q-registers} gefunden werden, der dazugehörige Initialisierungscode in Listing~\ref{lst:mma8451q-init}.

\begin{lstlisting}[style=lolc,caption={Registerstruktur MMA8451Q},label=lst:mma8451q-registers]
typedef struct {
	uint8_t F_SETUP;		/*< FIFO setup */
	uint8_t TRIG_CFG;		/*< Map of FIFO data capture events */
	const uint8_t SYSMOD;		/*< Current System Mode */
	/* skipped 1 register */
	const uint8_t WHO_AM_I;		/*< Device ID (0x1A) */
	uint8_t XYZ_DATA_CFG;		/*< Dynamic Range Settings */
	uint8_t HP_FILTER_CUTOFF;	/*< Cutoff frequency */
	/* skipped 1 register */
	uint8_t PL_CFG;			/*< Landscape/Portrait configuration */
	uint8_t PL_COUNT;		/*< Landscape/Portrait debounce counter */
	uint8_t PL_BF_ZCOMP;		/*< Back/Front, Z-Lock Trip threshold */
	uint8_t P_L_THS_REG;		/*< Portrait to Landscape Trip Angle */
	uint8_t FF_MT_CFG;		/*< Freefall/Motion functional block configuration */
	/* skipped 1 register */ 
	uint8_t FF_MT_THS;		/*< Freefall/Motion threshold register */
	uint8_t FF_MT_COUNT;		/*< Freefall/Motion debounce counter */
	/* skipped 4 registers */
	uint8_t TRANSIENT_CFG;		/*< Transient functional block configuration */
	uint8_t TRANSIENT_SCR;		/*< Transient event status register */
	uint8_t TRANSIENT_THS;		/*< Transient event threshold */
	uint8_t TRANSIENT_COUNT;	/*< Transient debounce counter */
	uint8_t PULSE_CFG;		/*< ELE, Double_XYZ or Single_XYZ */
	/* skipped 1 register */
	uint8_t PULSE_THSX;		/*< X pulse threshold */
	uint8_t PULSE_THSY;		/*< Y pulse threshold */
	uint8_t PULSE_THSZ;		/*< Z pulse threshold */
	uint8_t PULSE_TMLT;		/*< Time limit for pulse */
	uint8_t PULSE_LTCY;		/*< Latency time for 2nd pulse */
	uint8_t PULSE_WIND;		/*< Window time for 2nd pulse */
	uint8_t ASLP_COUNT;		/*< Counter setting for Auto-SLEEP */
	uint8_t CTRL_REG1;		/*< ODR, Active/Standby mode */
	uint8_t CTRL_REG2;		/*< Sleep Enable, OS Modes */
	uint8_t CTRL_REG3;		/*< Wake from Sleep, IPOL, PP_OD */
	uint8_t CTRL_REG4;		/*< Interrupt enable register */
	uint8_t CTRL_REG5;		/*< Interrupt pin (INT1/INT2) map */
	uint8_t OFF_X;			/*< X-axis offset adjust */
	uint8_t OFF_Y;			/*< Y-axis offset adjust */
	uint8_t OFF_Z;			/*< Z-axis offset adjust */
} mma8451q_confreg_t;
\end{lstlisting}

\todo{Initialisierungscode}

\begin{lstlisting}[style=lolc,caption={Initialisierungscode MMA8451Q},label=lst:mma8451q-init]
/* Referenz auf statischen shared buffer */
mpu6050_confreg_t *configuration = &config_buffer.mma8451q_configuration;

/* Sensor zuruecksetzen, wenn System aus dem Warmstart kommt */
MMA8451Q_EnterPassiveMode();
MMA8451Q_Reset();
delay_ms(20);

/* Konfiguration lesen */
MMA8451Q_FetchConfiguration(configuration);

/* 2g Sensitivitaet, Ausgabe-Hochpassfilter deaktiviert */
MMA8451Q_SetSensitivity(configuration, MMA8451Q_SENSITIVITY_2G, MMA8451Q_HPO_DISABLED);

/* 100 Hz Samplingrate, Low-Noise-Modus aktiviert */
MMA8451Q_SetDataRate(configuration, MMA8451Q_DATARATE_100Hz, MMA8451Q_LOWNOISE_ENABLED);

/* Oversamplingsmodus fuer hohe Aufloesung aktivieren */
MMA8451Q_SetOversampling(configuration, MMA8451Q_OVERSAMPLING_HIGHRESOLUTION);

/* Interrupt zuruecksetzen */
MMA8451Q_ClearInterruptConfiguration(configuration);

/* Interrupt auf Open Drain, Active Low setzen */
MMA8451Q_SetInterruptMode(configuration, MMA8451Q_INTMODE_OPENDRAIN, MMA8451Q_INTPOL_ACTIVELOW);

/* Data Ready-Interrupt auf Pin 2 legen */
MMA8451Q_ConfigureInterrupt(configuration, MMA8451Q_INT_DRDY, MMA8451Q_INTPIN_INT2);

/* Konfiguration senden und Sensor aktivieren */
MMA8451Q_StoreConfiguration(configuration);
MMA8451Q_EnterActiveMode();
\end{lstlisting}

\subsubsection{Kalibrierung}
\label{subsec:mma8451q_kalibrierung}

Eine Möglichkeit zur Offsetkalibrierung der Beschleunigungssensoren besteht darin, diese in Ruhelage so zu positionieren, dass der gesamte Betrag der durch die Gravitation bedingten
Beschleunigungskraft von nur einer Sensorachse gemessen wird. In dieser Lage werden Messwerte über den Verlauf einiger Minuten aufgenommen und das Verfahren für jede andere Achse und
Richtung wiederholt, so dass Messwerte für positive und negative Halbachsen vorliegen. Da die beiden jeweils nicht von der Gravitation beeinträchtigten Achsen nun mittelwertfrei sein müssen,
lässt sich aus den Messwerten direkt der Offsetfehler, sowie Drift und Varianz ablesen.

Da für jede Achse nun zwei Varianzmessungen vorliegen, können diese mittels der "`pooled"'-Varianzmethode als erwartungstreu gewichtete Mittelung zusammengeführt werden, so dass

\begin{align}
\mathrm{Var} \left[s_p \mid s_1, s_1\right] = \frac{(n_1 - 1)\mathrm{Var} \left[s_1\right] + (n_2 - 1)\mathrm{Var} \left[s_2\right]}{n_1 + n_2 - 2} \label{eq:pooled_variance}
\end{align}

wobei $n_{1,2}$ die Anzahl der vorliegenden Messwerte beziffert. Da diese Methode jedoch insgesamt fehleranfällig aufgrund der Notwendigkeit einer exakten Ausrichtung des Sensors ist 
und aufgrund der Natur der Aufgabe ohnehin nur unter Laborbedingungen durchgeführt werden kann, wurde im späteren Projektverlauf die unter Abschnitt~\ref{subsec:hmc5883l_kalibrierung} 
beschriebene Eigenvektormethode verwendet, wobei die Varianzen nach bekannten Offsetfehlern wie üblich aus einer Messung in Ruhelage gewonnen wurden. 

Da der Sensor im weiteren Verlauf des Projektes nicht mehr verwendet wurde, soll an dieser Stelle nicht tiefer auf die Vorgehensweise eingegangen werden.





\subsection{MPU6050 -- Accelerometer, Gyro- und Temperatursensor}
\label{sec:mpu6050}

Die Invensense MPU6050 ist eine \gls{imu}, die einen 16 Bit genauen Beschleunigungs- und Drehratensensor mit einem Temperatursensor vereinigt (\citealp{mpu6050}). 

\todo{8 kHz Gyro etc.}

Die \gls{mpu} bietet zusätzlich die Möglichkeit, über einen als slave betriebenen, zusätzlichen \gls{i2c}-Bus weitere Sensoren zu verarbeiten, wodurch Aufwand 
vom Hauptcontroller abfällt. Der \gls{mpu} zugeschaltet ist ein sog. \gls{dmp}, welcher die internen Daten, sowie die über den slave-Bus bezogenen externen Daten fusionieren kann. 
Obschon die Ergebnisregister des \gls{dmp} frei zugänglich sind, sind die Inhalte dieser Felder nicht dokumentiert. Der Zugriff auf sie erfolgt stattdessen --- sofern erwünscht --- 
über eine proprietäre MotionsApps-Firmware\footnote{\url{http://www.invensense.com/developers/forum/viewtopic.php?f=3&t=142}}. 
Diese wurde ob der Aufgabenstellung des Projektes explizit nicht verwendet.

Im Gegensatz zur MPU6000 verzichtet die MPU6050 auf den bis zu 20 MHz schnellen \gls{spi}-Bus, wodurch sich die maximale Zugriffsgeschwindigkeit auf 400 kHz auf dem \gls{i2c}-Bus 
beschränkt\footnote{Dies entspricht dem sog. "`Fast Mode \gls{i2c}"', welcher bis 400 kbit/s spezifiziert ist.}; Stattdessen ist der Logiklevel über einen \texttt{VLOGIC}-Pin frei wählbar. 
Diese vergleichsweise geringe Geschwindigkeit ist jedoch ausreichend, um den Sensor selbst bei voller Samplingrate auszulesen.

\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.5\textwidth]{./images/mpu6050-gyro-accelerometer.jpg}
		\caption[MPU6050 Breakout Board]{Verwendetes MPU6050 Breakout Board\\Quelle: Drotek}
		\label{fig:mpu6050-breakout}
\end{figure}

Für die Entwicklung verwendet wurde ein Breakout-Board von Drotek (Abbildung~\ref{fig:mpu6050-breakout}), welches neben einem $5\volt$-Eingang, sowie der \gls{i2c}-Schnittstelle (auf dem Bild zu erkennen sind die Pins für den Slave-\gls{i2c}-Bus der \gls{imu}) einen $3.3\volt$-Ausgang, sowie einen Interrupt-Ausgang (\texttt{DRDY}) besitzt, welcher das Vorliegen neuer Messwerte signalisiert.

\subsubsection{Treiber}

Die Registerstruktur der MPU6050 ist bei weitem die komplexeste der verwendeten Sensoren, sie kann in Listing~\ref{lst:mpu6050-registers} gefunden werden, der verwendete Initialisierungcode dagegen in Listing~\ref{lst:mpu6050-registers}. Insbesondere soll dort auf Zeile~\ref{lstline:mpu6050_osc} hingewiesen werden, auf die im Abschnitt~\ref{subsec:mpu6050_lessonslearned} gesondert eingegangen wird.

\begin{lstlisting}[style=lolc,caption={Registerstruktur MPU6050},label=lst:mpu6050-registers]
#pragma pack(1)
typedef struct __attribute__ ((__packed__))
{
	/* skipping registers 0x00 .. 0x0C */
	
	/* skipping self-test registers 0x0D .. 0x10 */
	
	/* skipping registers 0x11 .. 0x18 */
	
	uint8_t SMPLRT_DIV; 		/* Samplerate Divider */
	uint8_t CONFIG; 		/* MPU-Konfiguration */
	uint8_t GYRO_CONFIG; 		/* Gyro-Konfiguration */
	uint8_t ACCEL_CONFIG; 		/* Accelerometer-Konfiguration */
	
	/* skipping registers 0x1D .. 0x12 */
	
	uint8_t FIFO_EN; 		/* FIFO-Register */
	uint8_t I2C_MST_CTRL; 		/* Slave-I2C Control */
	uint8_t I2C_SLV0_ADDR; 		/* Slave-I2C 0 */
	uint8_t I2C_SLV0_REG; 		/* Slave-I2C 0 */
	uint8_t I2C_SLV0_CTRL; 		/* Slave-I2C 0 */
	uint8_t I2C_SLV1_ADDR; 		/* Slave-I2C 1 */
	uint8_t I2C_SLV1_REG; 		/* Slave-I2C 1 */
	uint8_t I2C_SLV1_CTRL; 		/* Slave-I2C 1 */
	uint8_t I2C_SLV2_ADDR; 		/* Slave-I2C 2 */
	uint8_t I2C_SLV2_REG; 		/* Slave-I2C 2 */
	uint8_t I2C_SLV2_CTRL; 		/* Slave-I2C 2 */
	uint8_t I2C_SLV3_ADDR; 		/* Slave-I2C 3 */
	uint8_t I2C_SLV3_REG; 		/* Slave-I2C 3 */
	uint8_t I2C_SLV3_CTRL; 		/* Slave-I2C 3 */
	uint8_t I2C_SLV4_ADDR; 		/* Slave-I2C 4 */
	uint8_t I2C_SLV4_REG; 		/* Slave-I2C 4 */
	uint8_t I2C_SLV4_DO; 		/* Slave-I2C 4 */
	uint8_t I2C_SLV4_CTRL; 		/* Slave-I2C 4 */
	const uint8_t I2C_SLV4_DI; 	/* Slave-I2C 4 */
	const uint8_t I2C_MST_STATUS;	/* Slave-I2C Status */
	uint8_t INT_PIN_CFG; 		/* Interrupt-Konfiguration */
	uint8_t INT_ENABLE; 		/* Interrupt-AKtivierung */

	/* skipping register 0x39 */
	
	/* skipping data status and value registers 0x3A .. 0x60 */
	
	/* skipping registers 0x61 .. 0x63 */
	
	uint8_t I2C_SLV0_DO; 		/* Slave-I2C 0 */
	uint8_t I2C_SLV1_DO; 		/* Slave-I2C 1 */
	uint8_t I2C_SLV2_DO; 		/* Slave-I2C 2 */
	uint8_t I2C_SLV3_DO; 		/* Slave-I2C 3 */
	uint8_t I2C_MST_DELAY_CTRL; 	/* Slave-I2C Control */
	uint8_t SIGNAL_PATH_RESET; 	/* Reset */
	uint8_t MOT_DETECT_CTRL; 	/* Motion Detection */
	uint8_t USER_CTRL; 		/* Erweiterte Konfiguration */
	uint8_t PWR_MGMT_1; 		/* Energiemanagement */
	uint8_t PWR_MGMT_2; 		/* Energiemanagement */

	/* skipping registers 0x6D .. 0x71 */
	
	uint8_t FIFO_COUNTH; 		/* FIFO-Status */
	uint8_t FIFO_COUNTL; 		/* FIFO-Status */
	uint8_t FIFO_R_W; 		/* FIFO-Daten */
	const uint8_t WHO_AM_I; 	/* Identifikation */
} mpu6050_confreg_t;
\end{lstlisting}

\todo{Initialisierungscode}

\begin{lstlisting}[style=lolc,caption={Initialisierungscode MPU6050},label=lst:mpu6050-init]
/* Referenz auf statischen shared buffer */
mpu6050_confreg_t *configuration = &config_buffer.mpu6050_configuration;

/* Test auf I2C-Bus */
uint8_t value = MPU6050_WhoAmI();
assert(value == 0x68);

/* Interrupts deaktivieren und Clock auf internen Oszillator setzen */
MPU6050_SelectClockSource(MPU6050_CONFIGURE_DIRECT, MPU6050_CLOCK_8MHZOSC); %* \label{lstline:mpu6050_osc}*)
MPU6050_EnableInterrupts(MPU6050_CONFIGURE_DIRECT,
		MPU6050_INT_DISABLED,
		MPU6050_INT_DISABLED,
		MPU6050_INT_DISABLED); /* disable data ready interrupt */

/* Konfiguration beziehen */
MPU6050_FetchConfiguration(configuration);

/* Samplingrate setzen (8kHz, Division durch 40 --> 200Hz) */
MPU6050_SetGyroscopeSampleRateDivider(configuration, 40);

/* Wertebereich fuer Gyro: 2000 Grad/s */
/* Wertebereich fuer Accelerometer: 4g*/
MPU6050_SetGyroscopeFullScale(configuration, MPU6050_GYRO_FS_2000);
MPU6050_SetAccelerometerFullScale(configuration, MPU6050_ACC_FS_4);

/* Interrupts konfigurieren */
MPU6050_ConfigureInterrupts(configuration,
		MPU6050_INTLEVEL_ACTIVELOW,
		MPU6050_INTOPEN_OPENDRAIN,
		MPU6050_INTLATCH_LATCHED, /* if configured to PULSE the line goes postal */
		MPU6050_INTRDCLEAR_READSTATUS);
		
/* Interrupts aktivieren */
MPU6050_EnableInterrupts(configuration,
		MPU6050_INT_DISABLED,
		MPU6050_INT_DISABLED,
		MPU6050_INT_ENABLED); /* enable data ready interrupt */
		
/* Clock wieder auf Gyro-PLL setzen */
MPU6050_SelectClockSource(configuration, MPU6050_CLOCK_XGYROPLL);

/* Sleep mode deaktivieren und Konfiguration setzen */
MPU6050_SetSleepMode(configuration, MPU6050_SLEEP_DISABLED);
MPU6050_StoreConfiguration(configuration);
\end{lstlisting}

\subsubsection{Kalibrierung}
\label{subsec:mpu6050_kalibrierung}

Die Kalibrierung des Accelerometers der MPU6050 wurde wie in Abschnitt~\ref{subsec:mma8451q_kalibrierung} beschrieben durchgeführt. Die Kalibrierung des Gyrosensors erfolgte durch Auswertung
der in Ruhelage gewonnenen Messwerte mittels einer linearen Regression, wobei die Arbeitstemperatur des Sensors als konstant und identisch zur Kalibrierungstemperatur angenommen wurde.
Da die lineare Regression sowohl Anstieg, als auch Verschiebung der Regressionsgerade liefert, sind damit Offset und Drift (in Form einer Winkelbeschleunigung) bekannt.
Nach erfolgter Regressionsbereinigung wurden die Messwertvarianzen ermittelt.

Eine Übersicht der unkalibrierten und kalibrierten Sensordaten ist in Abbildungen~\ref{fig:sensors_unagitated} und~\ref{fig:mpu6050_calib} zu finden.

\begin{figure}[htbp]
		\centering
		\begin{subfigure}[b]{\textwidth}
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/mpu6050/uncalib_3d.png}
				%\caption{Unkalibrierter Sensor\\Übersicht}
			\end{subfigure}~\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/mpu6050/calib_3d.png}
				%\caption{Kalibrierter Sensor\\Übersicht}
			\end{subfigure}
			\caption{Übersicht des Ellipsoiden}
		\end{subfigure}
		
		\begin{subfigure}[b]{\textwidth}
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/mpu6050/uncalib_xy.png}
				%\caption{Unkalibrierter Sensor\\X/Y-Ebene}
			\end{subfigure}%
			~
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/mpu6050/calib_xy.png}
				%\caption{Kalibrierter Sensor\\X/Y-Ebene}
			\end{subfigure}
			\caption{$X/Y$-Projektion}
		\end{subfigure}
		
		\begin{subfigure}[b]{\textwidth}
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/mpu6050/uncalib_xz.png}
				%\caption{Unkalibrierter Sensor\\X/Z-Ebene}
			\end{subfigure}%
			~
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/mpu6050/calib_xz.png}
				%\caption{Kalibrierter Sensor\\X/Z-Ebene}
			\end{subfigure}
			\caption{$X/Z$-Projektion}
		\end{subfigure}
		
		\begin{subfigure}[b]{\textwidth}
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/mpu6050/uncalib_yz.png}
				%\caption{Unkalibrierter Sensor\\Y/Z-Ebene}
			\end{subfigure}%
			~
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/mpu6050/calib_yz.png}
				%\caption{Kalibrierter Sensor\\Y/Z-Ebene}
			\end{subfigure}
			\caption{$Y/Z$-Projektion}
		\end{subfigure}
		
		\caption[MPU6050: Kalibrierte und unkalibrierte Sensordaten]{MPU6050: Unkalibrierte (links) und kalibrierte Sensordaten (rechts) mit den Ellipsoid-Halbachsen.}
		\label{fig:mpu6050_calib}
\end{figure}

\subsubsection{Lessons Learned}
\label{subsec:mpu6050_lessonslearned}

Bei der Kommunikation mit der MPU6050 trat das Problem auf, dass bei aktiviertem Interrupt-Signal und reduzierter Samplingrate nach einem Kaltstart keinerlei nennenswerte 
Verzögerung (d.h. nur im Mikrosekundenbereich) zwischen aufeinander folgenden Interruptsignalen festzustellen war vgl. Abbildung~\ref{fig:logan-frenzy}). 
Dies führte zu der Problematik, dass die durch den Interrupt-Handler freigeschaltete Routine zum Beziehen der Sensordaten über \gls{i2c} und die anschließende Verarbeitung 
direkt durch einen erneuten Interrupt unterbrochen wurde. Da die serielle Ausgabe der Werte über die \gls{uart}-Schnittstelle nur mit deutlich geringerer Taktung laufen
kann\footnote{Bis zu 230.4 kbaud konnten umgesetzt werden}, führte dies zu einem Engpass am vorgeschalteten Ausgabepuffer, wodurch die Verarbeitung deutlich blockiert wurde.

Wurde das System anschließend jedoch durch einen Reset (d.h. einen Warmstart) neu initialisiert, verlief die Kommunikation wie gewünscht. Ein weiterer Kaltstart führte den
fehlerhaften Zustand erneut herbei und konnte dann ebenso durch einen Reset aufgelöst werden.

\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.8\textwidth]{./images/logan-freifeuer.png}
		\caption[Fehlerhaftes IRQ-Signal in der MPU6050]{Fehlerhaftes Data Ready-Signal in der MPU6050 (vgl. Abbildung~\ref{fig:logan-full}). Pfeil: $3.07 \milli\second$, Interrupt-Pulsbreiten: $12.125 \micro\second$ ($82 \kilo\hertz$) bis $0.1 \milli\second$ ($10 \kilo\hertz$).}
		\label{fig:logan-frenzy}
\end{figure}

Dieses Problem war erst dadurch zu beheben, dass zu Beginn der Konfiguration der \gls{imu} die interne Takteinheit vom Gyro-\gls{pll}-Modus in den Oszillatormodus geschaltet wurde, 
um sie dann im Zuge der folgenden Konfiguration erneut auf den gewünschten Betriebsmodus zu stellen (vgl. dazu Listing~\ref{lst:mpu6050-registers}, 
Zeile~\ref{lstline:mpu6050_osc}). Das korrekte Verhalten kann in Abbildung~\ref{fig:logan-full} gesehen werden.

Eine initiale (zu geringe) Einschätzung über die möglichen Rotationsgeschwindigkeiten führte zu einem Betrieb des Gyrosensors im Sättigungsbereich, was die Fusion deutlich beeinträchtigte;
Da den Gyrosensordaten in der Fusion i.a. mehr Vertrauen geschenkt wird als den vergleichsweise ungenaueren Accelerometerdaten wird die (fusionierte) Rotation vorzeitig stark verlangsamt,
da die Winkelgeschwindigkeiten nicht hoch genug gemeldet werden können. Dies resultiert in einem schleppenden (d.h. mehrsekündigem) "`Nachziehen"' der Orientierung, während das Filter
die eigene Schätzung mit den Accelerometerdaten in Übereinstimmung bringt. Eine Darstellung des Sättigungseffektes bei einer schnellen Rotation aus der Hand findet sich in Abbildung \ref{fig:gyro-sat-unsat}.
Der Betrieb des Gyrosensors im $2000^\circ/\second$-Modus löste das Problem instantan. Für Anwendungen mit geringeren Dynamikanforderungen muss die Auflösung entsprechend angepasst werden.








\subsection{HMC5883L -- Magnetometer}
\label{sec:hmc5883l}

Der HMC5883L von Honeywell liefert bei einer Auflösung von 12 Bit (inkl. Vorzeichen) Messwerte in einem Bereich von bis zu $\pm$8 Gauss, wodurch er für den Einsatz in Präsenz starker 
lokaler Magnetfelder geeignet ist. Er arbeitet mit einer maximalen Samplingrate von 160 Hz und kann mit maximal 400 kHz über den \gls{i2c}-Bus ausgelesen 
werden\footnote{Dies entspricht dem sog. "`Fast Mode \gls{i2c}"'', welcher bis 400 kbit/s spezifiziert ist.}.

\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.65\textwidth]{./images/hmc5883l-magnetometer-compass-sensor.jpg}
		\caption[HMC5883L Breakout Board]{Verwendetes HMC5883L Breakout Board\\Quelle: Drotek}
		\label{fig:hmc5883l-breakout}
\end{figure}

Wie die MPU6050 besitzt auch der HMC5883L eine Interrupt-Leitung für das Vorliegen neuer Messwerte (\texttt{DRDY}). Das verwendete Breakout-Board von Drotek (Abbildung~\ref{fig:hmc5883l-breakout}) 
führt diesen Pin jedoch nicht heraus, weswegen auf periodisches Pollen des Sensors ausgewichen werden musste. Hierzu wurde auf die Funktionalität des \gls{systick}-Interrupt 
des ARM-Cores zurückgegriffen.

\subsubsection{Treiber}

Im Gegensatz zu den anderen verwendeten Sensoren fällt die Registerstruktur beim HMC5885L überaus knapp aus (Listing~\ref{lst:hmc5883l-registers}).

\begin{lstlisting}[style=lolc,caption={Registerstruktur HMC5883L},label=lst:hmc5883l-registers]
typedef struct {
	uint8_t CRA;	/*! Configuration Register A */
	uint8_t CRB;	/*! Configuration Register B */
	uint8_t MR;	/*! Mode Register */
} hmc5883l_confreg_t;
\end{lstlisting}

Entsprechend überschaubar ist auch die Initialisierungsroutine (Listing~\ref{lst:hmc5883l-init}).
\todo{Initialisierungscode}

\begin{lstlisting}[style=lolc,caption={Initialisierungscode HMC5883L},label=lst:hmc5883l-init]
/* Referenz auf statischen shared buffer */
hmc5883l_confreg_t *configuration = &config_buffer.hmc5883l_configuration;

/* I2C-Bustest */
uint32_t ident = HMC5883L_Identification();
assert(ident == 0x00483433);

/* Konfiguration lesen */
HMC5883L_FetchConfiguration(configuration);

/* Wertemittelung deaktivieren */
HMC5883L_SetAveraging(configuration, HMC5883L_MA_1);

/* Samplingrate auf 75 Hz */
HMC5883L_SetOutputRate(configuration, HMC5883L_DO_75Hz);

/* Normalen Messmodus aktivieren */
HMC5883L_SetMeasurementMode(configuration, HMC5883L_MS_NORMAL);

/* Gain auf Standardwert setzen */
HMC5883L_SetGain(configuration, HMC5883L_GN_1090_1p3Ga);

/* Kontinuierliche Messung aktivieren und Daten sichern */
HMC5883L_SetOperatingMode(configuration, HMC5883L_MD_CONT);
HMC5883L_StoreConfiguration(configuration);
\end{lstlisting}

\subsubsection{Kalibrierung}
\label{subsec:hmc5883l_kalibrierung}

Auf das magnetische Feld wirken zwei Effekte, denen hinsichtlich der Auswertung und Kalibrierung der Sensordaten besondere Aufmerksamkeit geschenkt werden muss. 
Diese nennt man entsprechend ihrer verursachenden ferromagnetischen Stoffe \glslink{hard iron}{Hard-} bzw. \glslink{soft iron}{Soft-Iron-Effekt}.

Beim \gls{hard iron} handelt es sich um eine durch "`harte"' ferromagnetische Stoffe verursachte lineare Verschiebung des Magnetfeldes; 
Im Gegensatz hierzu handelt es sich beim \gls{soft iron} um eine durch "`weiche"' ferromagnetische Stoffe verursachte nichtlineare Verzerrung der Feldlinien (vgl. Abbildung~\ref{fig:navpers_hi}).

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.4\textwidth]{./images/soft-iron-magnetic-field-navy.png}
	\caption[Soft-Iron-Effekt]{Soft-Iron-Effekt, Quelle: \cite{NAVPERS10548}}
	\label{fig:navpers_hi}
\end{figure}

Während sich ersterer Effekt im Sensor noch als reine Offsetverschiebung bemerkbar macht (vgl. Abbildung~\ref{fig:sensors_unagitated}), äußert sich letzterer als eine 
Streckung und Rotation der Messfeldkugel in einen rotierten Ellipsoiden im $\mathbb{R}^3$. In Abbildung~\ref{fig:hmc5883l_calib} findet sich eine Gegenüberstellung der 
unkalibrierten und kalibrierten Sensordaten; Hier sind die Auswirkungen solcher vorherrschenden \glslink{hard iron}{Hard-Iron}- und \glslink{soft iron}{Soft-Iron}-Verzerrungen 
deutlich zu erkennen.

Aufgrund der hohen Komplexität der Analyse des Magnetfeldes ist eine dynamische Kalibrierung on-the-fly, wie sie etwa von Smartphones bekannt ist, nicht ohne weiteres umzusetzen. Aus diesem
Grunde wurde die Kalibrierung auf eine statische Auswertung der durch das messende System selbst --- etwa durch Leiterbahnen --- bedingten Verzerrungen beschränkt. Liegen die hieraus
gewonnenen Koeffizienten vor, können die Effekte zur Laufzeit mittels einer affinen Transformation ($\mathbb{R}^{3 \times 4}$) kompensiert werden. 
Eine Übersicht der unkalibrierten und kalibrierten Sensordaten ist in Abbildungen~\ref{fig:sensors_unagitated} und~\ref{fig:hmc5883l_calib} zu finden.

Zur Kalibrierung wurden über einen Zeitraum von einigen Minuten Daten des Magnetometers in MATLAB aufgezeichnet. Während dieser Zeit wurde die Orientierung des Sensors
so verändert, dass ein frei gewählter Punkt im Raum (in vorliegenden Fall die magnetische Nord-Richtung) auf jeder Sensorachse positiv, wie negativ messbar wurde.
Hierbei war anzunehmen, dass sich das stärkste Magnetfeld in der Umgebung des Sensors --- das Erdmagnetfeld --- über den Verlauf der Messung nicht veränderte.
Da der Sensor jedoch gerade die Richtung und Amplitude des stärksten Magnetfeldes in Form eines Vektors im $\mathbb{R}^3$ misst, musste dies über die Zeit der Messung zur Abbildung 
einer Kugelschale durch die Messwerte führen (vgl Abb.~\ref{fig:hmc5883l_calib}, links).

Die so vorliegende $3 \times N$-Matrix der $N$ Messwerte wurde dann mittels der MATLAB-Funktion \texttt{eig} in Eigenwerte und -Vektoren zerlegt. Da es sich (per eben festgelegter Definition) 
bei den aufgezeichneten Daten um Punkte auf einer Ellipsoidenhülle handelt, entsprechen die so gewonnenen Eigenvektoren den jeweiligen Richtungsvektoren der Halbachsen 
$\vec{x}_V, \vec{y}_V, \vec{z}_V$ des Ellipsoiden, wobei die Eigenwerte den zugehörigen Längen der Halbachsen entsprechen. Mit der Kenntnis der Halbachsen lässt sich weiterhin der Mittelpunkt
des Ellipsoiden ermitteln, wodurch der \gls{hard iron} kompensiert werden kann.

Zur Gewinnung der Koeffizienten der affinen Korrekturmatrix wurde nun wie folgt vorgegangen:

 \begin{enumerate}
		\item Die Orientierung des Ellipsoids wird aus den Eigenvektoren gewonnen.
		\item Mittels einer inversen Rotation $\underline{R}^T$ wird der Ellipsoid mit dem Referenzkoordinatensystem in Übereinstimmung gebracht.
		\item Die Achsen des Ellipsoiden werden nun anhand der Eigenwerte auf einen beliebigen Wert\footnote{Die Wahl dieses Wertes ist abhängig davon, ob die Kenntnis der echten Stärke des Magnetfeldes für die weitere Verarbeitung notwendig ist. Im vorliegenden Fall sind nur die Richtungen von Belang.} $\underline{S}$ normalisiert.
		\item Die Rotation $\underline{R}$ wird in nicht-invers angewandt, um die ursprüngliche Orientierung des Ellipsoiden wiederherzustellen.
		\item Die Offset-Korrektur $\underline{T}$ wird angewandt.
\end{enumerate}

Das MATLAB-Skript zum Einpassen eines Ellipsoiden aus einer Punktmenge kann in Listing~\ref{lst:matlab-ellipsoid} und auf MATLAB File Exchange (\citealp{petrov_matlab}) gefunden werden.

Die Orientierung wird dabei als Winkelkosinusmatrix $\underline{R}$ (dazu mehr in Abschnitt~\ref{subsec:herleitung_dcm}) zwischen Referenzsystem $\underline{E}$ und Eigenvektor $\underline{V}$ bezogen, so dass

\begin{align}
\underline{R} = \underline{E} \cdot \underline{V}
\end{align}

Die Kombination der Operationen führt zur einer affinen $3 \times 4$-Transformationsmatrix

\begin{align}
\underline{A} = \underline{R} \cdot \underline{S} \cdot \underline{R}^T - \underline{T}
\end{align}

mittels welcher nun jeder neue Messwert hinsichtlich der o.g. Effekte korrigiert werden kann. Hilfreich ist hierbei die \gls{mac}-Struktur der Operation, welche durch 
die \texttt{(U)MLA(L)}\footnote{multiply and (unsigned) accumulate (long)}- bzw. \texttt{(U)MLS}\footnote{multiply and (unsigned) subtract}-Operationen 
des \gls{Thumb2}-Befehlssatzes effizient verarbeitet werden kann (vgl. \citealp{thumb2}).

\begin{figure}[htbp]
		\centering
		\begin{subfigure}[b]{\textwidth}
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/uncalib_3d.png}
				%\caption{Unkalibrierter Sensor\\Übersicht}
			\end{subfigure}~\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/calib_3d.png}
				%\caption{Kalibrierter Sensor\\Übersicht}
			\end{subfigure}
			\caption{Übersicht des Ellipsoiden}
		\end{subfigure}
		
		\begin{subfigure}[b]{\textwidth}
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/uncalib_xy.png}
				%\caption{Unkalibrierter Sensor\\X/Y-Ebene}
			\end{subfigure}%
			~
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/calib_xy.png}
				%\caption{Kalibrierter Sensor\\X/Y-Ebene}
			\end{subfigure}
			\caption{$X/Y$-Projektion}
		\end{subfigure}
		
		\begin{subfigure}[b]{\textwidth}
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/uncalib_xz.png}
				%\caption{Unkalibrierter Sensor\\X/Z-Ebene}
			\end{subfigure}%
			~
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/calib_xz.png}
				%\caption{Kalibrierter Sensor\\X/Z-Ebene}
			\end{subfigure}
			\caption{$X/Z$-Projektion}
		\end{subfigure}
		
		\begin{subfigure}[b]{\textwidth}
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/uncalib_yz.png}
				%\caption{Unkalibrierter Sensor\\Y/Z-Ebene}
			\end{subfigure}%
			~
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/calib_yz.png}
				%\caption{Kalibrierter Sensor\\Y/Z-Ebene}
			\end{subfigure}
			\caption{$Y/Z$-Projektion}
		\end{subfigure}
		
		\caption[HMC5883L: Kalibrierte und unkalibrierte Sensordaten]{HMC5883L: Unkalibrierte (links) und kalibrierte Sensordaten (rechts) mit den Ellipsoid-Halbachsen.}
		\label{fig:hmc5883l_calib}
\end{figure}



\subsubsection{Lessons Learned}

Bei der Auswertung der Sensordaten des HMC5883L traten zweierlei Komplikationen auf. Eines dieser Probleme lag in der Ansteuerung des Sensors, das andere dagegen in der Interpretation der Messwerte begründet.

\subsubsection{Reihenfolge der Messwerte}
\label{subsec:hmc5885l_reihenfolge}

Während in anderen getesteten Sensoren die Messwerte in üblicher $X,Y,Z$-Reihenfolge vorlagen, speichert der HMC5883L die Messwerte in der Reihenfolge $X,Z,Y$. 
Dies ist aus dem Datenblatt (\citealp{hmc5883l}) nur dann ersichtlich, wenn die dort vorliegende --- extrem kurze --- Registerliste (S. 11) sehr genau beachtet wird. 
Im Gegensatz zu der dort aufgeführten korrekten Reihenfolge, benennen sämtliche übrigen Stellen des Datenblattes (insbesondere im Abschnitt Data Output Registers, S. 15) die reguläre Anordnung.
Dieser Fehler allein wäre schnell aufgefallen, überlagerte sich jedoch mit der auf Seite~\pageref{subsec:hmc5885l_interpretation} beschriebenen Interpretationsproblematik.

\subsubsection{Interpretation der unkalibrierten Messergebnisse}
\label{subsec:hmc5885l_interpretation}

Das zweite Problem bei der Verarbeitung der Magnetometerdaten bestand in der Verweigerung des Erdmagnetfeldes, die erwartete Form anzunehmen.

Der Grund für die Fehlannahme bezüglich der Ergebnisse lag hierbei allein in der visuellen Vorstellung des Verlaufes der Magnetfeldlinien. Dies wird durch die große Menge an qualitativ stark
divergierenden Darstellungen des Erdmagnetfeldes, in Lehrbüchern wie Infografiken als stilisierter Stabmagnet o.ä., nicht erleichtert. Ein Beispiel hierfür findet sich 
in Abbildung~\ref{fig:magnetfeld_erde_hmpf}. Es wurde angenommen, dass eine Rotation um die Hochachse $Z$ des Sensors zu einer Anordnung der Messwerte auf einer Kreisbahn signifikanten Radius' führen
würde. Der hierfür angenommene flache Eintrittswinkel der Magnetfeldlinien entsprach jedoch nicht der Realität. Wie stark die erwartete Richtung ("`nord"', "`in etwa vorwärts"', "`durch den Erdball zum Nordpol"')
von der tatsächlich Richtung des Magnetfeldvektors abweichen kann\footnote{Messung in Berlin, Deutschland}, ist in Abbildung~\ref{fig:vektorobs_visual_coord} ersichtlich: Der Winkel zwischen 
Gravitations- und Magnetfeldvektor beträgt dort nur knapp $45^\circ$.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/raw_uncalib_around_z_up.png}
	\caption[HMC5883L: Rotation um angenommene $Z$-Achse bei unkalibriertem Sensor]{HMC5883L: Rotation um angenommene $Z$-Achse bei unkalibriertem Sensor}
	\label{fig:hmc5883l_idiotenmessung}
\end{figure}

In Verbindung mit dem im Abschnitt~\ref{subsec:hmc5885l_reihenfolge} beschriebenen Achsenproblem fiel es schwer, aus den so gewonnenen Messdaten (siehe Abbildung~\ref{fig:hmc5883l_idiotenmessung}) Nutzen zu gewinnen, da sowohl die Orientierung, als auch der erwartete Radius des Messwertkreises aus dem Rahmen fielen.

Ein Vergleich mit der korrekten und kalibrierten Anordnung der Messwerte in Abbildung~\ref{fig:hmc5883l_calib_raw} zeigt den Ist- und Soll-Zustand. In beiden Fällen wurden die Messungen einmal in normaler (d.h. aufrechter) Ausrichtung des Sensors, sowie in inverser Ausrichtung desselben ("`auf dem Kopf"') ausgemessen.

\begin{figure}[htbp]
		\centering
		\begin{subfigure}[b]{0.5\textwidth}
			\centering
			\includegraphics[width=\textwidth]{./images/earth_magnetic_field_poles_shutterstock.jpg}
			\caption{Populistische Darstellung \\ Quelle: Shutterstock}
		\end{subfigure}%
		~
		\begin{subfigure}[b]{0.5\textwidth}
			\centering
			\includegraphics[width=\textwidth]{./images/Dipole_field_wikibooks.jpg}
			\caption{Vereinfachte realistische Darstellung \\ Quelle: Wikibooks}
		\end{subfigure}%
		\caption[Darstellungen des Erdmagnetfeldes]{Darstellungen des Erdmagnetfeldes.\\Links: Die Feldlinien treffen sich an den Polen.\\Rechts: Die Feldlinien durchdringen den Erdmantel.}
		\label{fig:magnetfeld_erde_hmpf}
\end{figure}


\begin{figure}[htbp]
		\centering
		\begin{subfigure}[b]{\textwidth}
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/raw_uncalib_around_x_fwd.png}
				%\caption{Unkalibrierter Sensor\\Übersicht}
			\end{subfigure}~\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/raw_calib_around_x_fwd.png}
				%\caption{Kalibrierter Sensor\\Übersicht}
			\end{subfigure}
			\caption{Rotation um die $X$-Achse (vor- und rückwärtsgerichtet)}
		\end{subfigure}
		
		\begin{subfigure}[b]{\textwidth}
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/raw_uncalib_around_y_lft.png}
				%\caption{Unkalibrierter Sensor\\X/Y-Ebene}
			\end{subfigure}%
			~
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/raw_calib_around_y_lft.png}
				%\caption{Kalibrierter Sensor\\X/Y-Ebene}
			\end{subfigure}
			\caption{Rotation um die $Y$-Achse (links- und rechtsgerichtet)}
		\end{subfigure}
		
		\begin{subfigure}[b]{\textwidth}
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/raw_uncalib_around_z_up.png}
				%\caption{Unkalibrierter Sensor\\X/Z-Ebene}
			\end{subfigure}%
			~
			\begin{subfigure}[b]{0.5\textwidth}
				\centering
				\includegraphics[width=\textwidth]{./images/sensors/hmc5883l/raw_calib_around_z_up.png}
				%\caption{Kalibrierter Sensor\\X/Z-Ebene}
			\end{subfigure}
			\caption{Rotation um die $Z$-Achse (auf- und abwärtsgerichtet)}
		\end{subfigure}
				
		\caption[HMC5883L: Messungen einzelner Rotationen]{HMC5883L: Unkalibrierte (links) und kalibrierte Sensordaten (rechts). Jeweils normale und inverse Orientierung des Sensors überlagert.}
		\label{fig:hmc5883l_calib_raw}
\end{figure}
