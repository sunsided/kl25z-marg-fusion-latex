\setchapterpreamble[u]{%
\dictum[Luhmann]{Die Klassiker sind Klassiker, weil sie Klassiker sind \dots}}
\chapter{Fusionsalgorithmus}

Allen Fusionsalgorithmen gemein ist die Problematik, dass die Verwendung \textsc{Euler}'scher Winkel --- trotz oder eben gerade wegen ihrer Einfachheit --- zu 
nicht auflösbaren Singularitäten führt. Dieses Phänomen wird \gls{Gimbal Lock} genannt, nach dem englischen Namens des kardanischen Kreisel (siehe Abbildung~\ref{fig:kardanischer_kreisel}),
bei dem dieser Effekt deutlich wird.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.3\textwidth]{./images/kardanischer_kreisel.png}
	\caption[Kardanischer Kreisel]{Darstellung eines kardanischen Kreisels.\\Quelle: Prof. Dr. G. Flügge: Experimentalphysik I: Mechanik, RHTW Aachen}
	\label{fig:kardanischer_kreisel}
\end{figure}


Abhängig von der Wahl des Rotationsmodells etwa als Euler\footnote{Rotationsfolgen $Z\text{--}X\text{--}Z$, $X\text{--}Y\text{--}X$, $Y\text{--}Z\text{--}Y$, 
$Z\text{--}Y\text{--}Z$, $X\text{--}Z\text{--}X$ und $Y\text{--}X\text{--}Y$}- oder der in der Technik (vgl. DIN 9300, DIN 70000) üblicheren 
Tait-Bryan-Folge\footnote{Rotationsfolgen $X\text{--}Y\text{--}Z$, $Y\text{--}Z\text{--}X$, $Z\text{--}X\text{--}Y$, 
$X\text{--}Z\text{--}Y$, $Z\text{--}Y\text{--}X$ und $Y\text{--}X\text{--}Z$}, existieren hierbei unterschiedliche Rotationskonstellationen
mit nicht eindeutig bestimmbaren Winkeln. Dies ist im Falle des kardanischen Kreisels immer dann der Fall, wenn sich zwei direkt nebeneinander liegende Ringe  
durch geeignete Wahl der Rotationen in derselben Ebene befinden, wodurch eine beliebige Rotation des äußeren der beiden Ringe auch immer eine --- d.h. dieselbe! --- Rotation des inneren Ringes
bewirkt, was dem Verlust eines Freiheitsgrades des Systems entspricht. In solchen Fällen ist es oft nur noch möglich, einen einzelnen Winkel 
(etwa eine Neigung $\theta$) exakt anzugeben, wobei für die verbleibenden Winkel lediglich eine Bedingung der Art $\left|\phi + \psi \right| \leq 180^\circ$ angegeben werden kann.

Die Auswirkungen dieses Effektes in der Praxis sind in Abbildung~\ref{fig:euler_extrakt} deutlich ersichtlich. Hierbei wurde das System
über eine Zeit von ca. 40 Sekunden zweimal um jede seiner Achsen rotiert, wobei bei vorausgesetztem $Z\text{--}Y\text{--}X$-System\footnote{"`yaw-pitch-roll"'} 
ein Nickwinkel (Pitch, Elevation) von $\theta = \pm 90^\circ$ zu einer Singularität auf den Achsen $\phi$ (Yaw, Azimuth) und $\psi$ (Roll) führte.

Verschiedene Ansätze zur Orientierungserkennung unter Vermeidung \textsc{Euler}'scher Winkel werden daher in der Literatur behandelt. 
\cite{madgwick_quat}, \cite{indirect_quaternion_kalman} und \cite{vecops} formulieren \gls{Quaternion}-basierte \gls{marg}-Fusionsalgorithmen.
In der Quadrocopter-Bastlerszene großer Beliebtheit erfreut sich aufgrund seiner geringen Komplexität der von \cite{dcmdraft} vorgeschlagene 
Fusionsalgorithmus auf Basis der Winkelkosinusmatrix (\gls{dcm}) in Kombination mit einem \gls{Komplementaerfilter}, wie er von \cite{mahony_comp_eucl}, 
\cite{mahony_coupled} und \cite{mahony_compl} beschrieben wird.

Das \gls{Komplementaerfilter} wird als sich im Frequenzband komplementierende Zusammenstellung von Hoch- und Tiefpassfiltern implementiert, welche -- im vorliegenden Szenario -- 
die Vorteile der hohen Genauigkeit des Gyrosensors (ohne dessen Drift) mit jenen der hohen Dynamik des Accelerometers (ohne dessen Streuung) kombinieren.

Untersuchungen finden sich weiterhin zu den sog. Erweiterten \glslink{Kalman-Filter}{Kalman-Filtern} (z.B. \citealp{yadlin09} und \citealp{indirect_quaternion_kalman}), 
sowie den Unscented \glslink{Kalman-Filter}{Kalman-Filtern}\footnote{Einer Variation des erweiterten \glslink{Kalman-Filter}{Kalman-Filters} unter Zuhilfenahme der 
Unscented-Transformation, wodurch die Notwendigkeit der Linearisierung des Systems vermieden wird} (etwa \citealp{unscented}). Ferner existieren adaptive 
Varianten des \glslink{Kalman-Filter}{Kalman-Filters}, wie etwa von \cite{liwang12} untersucht.
Diese Arten von Filtern versuchen, die nichtlinearen Zusammenhänge des Systems --- allerdings auf Kosten der Komplexität des Filters --- direkt abzubilden. 

\cite{Tsang} vergleicht eine \gls{Quaternion}-Methode in einem erweiterten \gls{Kalman-Filter}, sowie die (bekanntermaßen problembehaftete) direkte Bestimmung der \textsc{Euler}'schen Winkel
mit einem Entwurf zur indirekten Schätzung der \gls{dcm} in einem regulären \gls{Kalman-Filter}. 
Er zeigt auf, dass die Verwendung des regulären Filters zur indirekten Schätzung trotz der Nichtlinearitäten keine inhärenten Nachteile mit sich bringt, 
sondern im Gegenteil mit der \gls{Quaternion}-Methode konkurrieren kann, weswegen dieser Algorithmus im Rahmen des Projektes umgesetzt wurde.
\cite{Filieri} beschreiben in diesem Zusammenhang ein Fehlermodell zur Schätzung der Beschleunigungs- und Integrationsunsicherheiten, welches unterstützend auch 
zur direkten Schätzung der Sensordrift angewendet werden kann. Dieser Aspekt wurde in MATLAB (erfolgreich) untersucht, jedoch nicht in der Firmware implementiert.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{./images/matlab/rollpitchyaw45-2.png}
	\caption[Extraktion der \textsc{Euler}'schen Winkel]{Extraktion der \textsc{Euler}'schen Winkel. Deutlich zu erkennen sind die Singularitäten bei Sekunden 13, 17 und 29 und 32.}
	\label{fig:euler_extrakt}
\end{figure}















\section{Bestimmung der Orientierung aus Vektorbeobachtungen}



\subsection{Herleitung der Winkelkosinusmatrix}

Aus der Definition des vektoriellen Skalarproduktes ("`Punktprodukt"'),

\begin{align}
\vec{a} \cdot \vec{b} &= \sum_{i=1}^{n} a_i b_i \quad \vec{a}, \vec{b} \in \mathbb{R}^n \label{eq:dot_sum} \\
										  &= \lvert \vec{a} \rvert \lvert \vec{b} \rvert \cos\left(\vec{a}, \vec{b}\right)
\end{align}

ergibt sich, dass der von zwei sich kreuzenden Vektoren eingeschlossene Winkel durch den Arkuskosinus ermittelbar ist. Die \glslink{dcm}{Winkelkosinusmatrix} (DCM) 
$\underline(A)$ nutzt diesen Zusammenhang zur Darstellung alle Winkelzusammenhänge zweier Systeme $\underline{S}_{\text{body}} = \left\{\vec{x}, \vec{y}, \vec{z} \right\}$, 
$\underline{S}_{\text{ref}} = \left\{\vec{X}, \vec{Y}, \vec{Z} \right\}$ 
(orthonormaler $\mathbb{R}^3$), so dass

\begin{align}
\underline{A} &= \begin{bmatrix}
\vec{x} \cdot \vec{X} & \vec{y} \cdot \vec{X} & \vec{z} \cdot \vec{X} \\
\vec{x} \cdot \vec{Y} & \vec{y} \cdot \vec{Y} & \vec{z} \cdot \vec{Y} \\
\vec{x} \cdot \vec{Z} & \vec{y} \cdot \vec{Z} & \vec{z} \cdot \vec{Z}
\end{bmatrix} \label{eq:dcm_long}
\end{align}

Wird das Koordinatensystem  $\underline{S}$ in Matrixform definiert, so dass

\begin{align}
\underline{S} &= \begin{bmatrix}
x_x & y_x & z_x \\
x_y & y_y & z_y \\
x_z & y_z & z_z
\end{bmatrix}
\end{align}

kann mittels der in Gleichung~\ref{eq:dot_sum} genannten Summendarstellung ersehen werden, dass Gleichung~\ref{eq:dcm_long} auch als

\begin{align}
\underline{A} &= \begin{bmatrix}
x_x & y_x & z_x \\
x_y & y_y & z_y \\
x_z & y_z & z_z
\end{bmatrix} \cdot \begin{bmatrix}
X_x & Y_x & Z_x \\
X_y & Y_y & Z_y \\
X_z & Y_z & Z_z
\end{bmatrix} = \underline{S}_{base} \cdot \underline{S}_{ref}  \label{eq:dcm_short}
\end{align}

formulierbar ist. Diese auch als

\begin{align}
\underline{A} &=
\begin{bmatrix}
\vec{x} \; \vdots \; \vec{y} \; \vdots \; \vec{z}\end{bmatrix} \cdot
\begin{bmatrix}
\vec{X} \; \vdots \; \vec{Y} \; \vdots \; \vec{Z}\end{bmatrix} \notag
\end{align}

bekannte Formulierung bildet den Kern des als \gls{triad}-Methode (vgl. \citealp{triad}) durch das Apollo-Programm bekannt gewordenen Algorithmus zur 
Orientierungserkennung aus drei\footnote{Hieraus ergibt sich der Name des Algorithmus.} Vektorbeobachtungen $\vec{x}, \vec{y}, \vec{z}$. 
Während das o.g. Beispiel orthonormale (oder bereits orthonormalisierte)
Vektoren voraussetzt, beschreibt \gls{triad} die Vorgehensweise unter Annahme nicht-orthonormaler Vektoren\footnote{Einen im Apollo-Programm als Sicherheitsmaßnahme umgesetzten Alternativalgorithmus bildet die \gls{quest}-Methode. Dessen Erweiterung, \gls{request}, wird u.a. von \cite{vecops} beschrieben.}, wie sie im 
Rahmen des Projektes vorliegen.

Ein Vorteil dieser Methode wird direkt ersichtlich, wenn das Referenzsystem $\underline{S}_{\text{ref}}$ als orthonormal zum Einheitssystem angenommen wird, d.h.

\begin{align}
\underline{S}_{\text{ref}} &= \underline{E}_3 = \begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{bmatrix}
\end{align}

In diesem Fall ergibt sich die \gls{dcm} $\underline{A}$ mittels Gleichung~\ref{eq:dcm_short} direkt als 

\begin{align}
\underline{A} &= \begin{bmatrix}
x_x & y_x & z_x \\
x_y & y_y & z_y \\
x_z & y_z & z_z
\end{bmatrix} = \begin{bmatrix} \vec{x} \; \vdots \; \vec{y} \; \vdots \; \vec{z}\end{bmatrix} = \underline{S}_{\text{body}}
\end{align}

Da die \gls{dcm} mit der \textsc{Euler}'schen Rotationsmatrix übereinstimmt, bedeutet dies, dass die Rotationsmatrix allein 
durch die Vektorbeobachtungen vollständig gegeben ist.




\subsection{Herleitung der Vektorbeobachtungen}



\begin{figure}[htbp]
		\centering
		
		\begin{subfigure}[b]{0.75\textwidth}
			\includegraphics[width=\textwidth]{./images/matlab/simulation_run_arrow.png}
			\caption{Darstellung als Pfeil}
			\label{fig:vektorobs_visual_arrow}
		\end{subfigure}
		
		\begin{subfigure}[b]{0.75\textwidth}
			\includegraphics[width=\textwidth]{./images/matlab/simulation_run_coord.png}
			\caption{Darstellung als Koordinatensystem. Dünne blaue Linie: Accelerometer (Gravitation). Dünne rote Linie: Magnetometer.}
			\label{fig:vektorobs_visual_coord}
		\end{subfigure}
		
		\caption{Visuelle Darstellung der Vektorbeobachtung}
		\label{fig:vektorobs_visual}
\end{figure}
